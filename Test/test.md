# 테스트

## 테스트 코드는 어떤식으로 작성해야 할까?
1. 작은 단위의 테스트
    * 테스트는 가능하면 작은 단위로 쪼갤 수 있어야 한다. 관심사의 분리가 테스트에도 적용된다. 테스트의 관심이 다르다면 테스트할 대상을 분리해서 접근해야 한다.
2. 자동 수행 테스트 코드
    * 자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것
    * 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해볼 수 있다.
3. 지속적인 개선과 점진적인 개발을 위한 테스트
    * 테스트를 이용하면 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지 확인할 수 있다.

## JUnit
* JUnit4에서도 독립적인 테스트를 보장하기 위해 각각의 테스트 클래스 객체를 생성하는데, 테스트 메소드를 선별하는 과정에서 @Test가 붙은 메소드 만을 테스트로 인식한다.
* JUnit5 부터는 public으로 만드는 전통을 풀어버렸다. 그래서 private 외의 접근제어자는 모두 사용할 수 있고, 일반적으로 default 접근자를 통해 손쉽게 타이핑할 수 있게 되었다.
* 하지만 여전히 테스트 클래스와 메소드는 반드시 public 이여야 한다.
* Junit5에서 assertThat 메서드가 없어지면서 assertAll, assertThrows와 같은 새로운 메소드가 생겼다.

## 테스트 결과의 일관성
* 단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다.
* DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

## 포괄적인 테스트
* 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
    * JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 
    * 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있도록 해야한다.

* 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다. 예외적인 상황을 고려하면 좋다.

## 테스트가 이끄는 개발
### 기능 설계를 위한 테스트
테스트에는 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용이 잘 표현되어 있다.
* 조건 : 어떤 조건을 가지고
* 행위 : 무엇을 할 때
* 결과 : 어떤 결과가 나온다.

### 테스트 주도개발(TDD, Test Driven Development, Test First Development)
* 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다.
* 테스트를 실행하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다.

## JUnit 주요 어노테이션
### @Before (JUnit 4), @BeforeEach (JUnit 5)
클래스 내에 존재하는 각각의 @Test 를 실행하기 전에 매번 실행돼야 하는 메소드를 정의한다.

### @BeforeClass (JUnit 4), @BeforeAll (JUnit 5)
모든 테스트를 실행하기 전 딱 한번만 실행돼야 하는 메소드를 정의한다. static 으로 선언해야 한다.

## 테스트 실행 흐름
![image](https://github.com/kmularise/TIL/assets/106499310/80805168-a9ce-419a-bfae-66eafd880a70)

1. 테스트 클래스에서 @Test가 void형인 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다. 모든 테스트의 결과를 종합해서 반환한다.

* 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다.
* 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 
* JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다.

## 픽스처
* 테스트를 수행히는 데 펼요한 정보나 오브젝트를 픽스처(fixture)라고 한다.
* 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.

## 스프링 테스트 적용
* 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.
* 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 히는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

## 스프링 테스트 컨텍스트 프레임워크
* JUnit 4 : @RunWith, JUnit 5 : @ExtendWith
    * JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용히는 애노테이션
    * Mockito의 Mock 객체를 사용하기 위한 Annotation
* SpringJUnit4ClassRunner와 같은 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.
* @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정

### 테스트 메소드의 컨텍스트 공유
스프링의 JUnit 확장 기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다. 일종의 DI라고 볼 수 있는데, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이 다르다.

하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다.

### 테스트 클래스의 컨텍스트 공유
두 개의 테스트 클래스가 같은 설정 파일을 사용하는 경우에는 테스트 수행 중에 단 한 개의 애플리케이션 컨텍스트만 만들어진다. 두 테스트 클래스의 모든 메소드가 하나의 애플리케이션 컨텍스트 공유할 수 있다.

수백 개의 테스트 클래스를 만들었는데 모두 같은 설정 파일을 사용한다고 하면 테스트 전체에 걸쳐 단 한 개의 애플리케이션 컨텍스트만 만들어져 사용된다.  이 덕분에 테스트 성능이 대폭 향상된다.

![image](https://github.com/kmularise/TIL/assets/106499310/2835fb49-f3a5-424f-a37a-63815350738a)

## @Autowired
* 스프링 DI에 사용되는 어노테이션
* @Autowired가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
* @Autowired는 타입으로 가져올 빈 하나를 선택 할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다. 변수의 이름이 두개여도 예외가 발생한다.
* 테스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없다. 개발자가 만드는 테스트는 코드 내부구조와 설정 등을 알고 있고 의도적으로 그 내용을 검증해야 할 필요가 있기 때문이다.
* 하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이좋다.
    * 이유 :
        1. 프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
        2. 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
        3. 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는게 중요하기 때문이다.

## DI를 이용한 테스트 방법 선택
* 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선적으로 고려한다. 
    * 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다. 
* 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우, 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.
    * 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정 파일을 따로 만들어 사용하는 편이 좋다. 
    * 보통 개발 환경과 테스트 환경, 운영 환경이 차이가 있기 때문에 각각 다른 설정 파일을 만들어 사용히는 경우가 일반적이다.
* 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다.
    * 이 때는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다.
    * 이 때, 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙여야 한다.