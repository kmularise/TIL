# TCP와 UDP
* TCP에만 연결(Connection, Session) 개념이 있다.
    * 연결 : 논리적
* 연결은 결과적으로 순서번호로 구현된다.
* 연결은 '상태(전이)' 개념을 동반한다.

## 포트 상태 정보
* CLOSED: 포트가 닫힌 상태
* LISTEN: 포트가 열린 상태로 연결 요청 대기 중
* SYN_RCV: SYNC 요청을 받고 상대방의 응답을 기다리는 중
* ESTABLISHED: 포트 연결 상태

## 3-way handshaking (연결 과정)
* TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정(Connection Establish)하는 과정
* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
* TCP/IP 프로토콜 : 응용 프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정

![image](https://github.com/kmularise/TIL/assets/106499310/3e9c64d9-28ac-4966-aa0e-19fa2579d094)
클라이언트(A)가 서버(B)에 연결을 요청
1. A -> B : SYN
* SYN : 접속 요청 프로세스 A가 연결 요청 메시지 전송 
* 송신자가 최초로 데이터를 전송할 때 Sequence Number를 임의의 랜덤 숫자로 지정하고, SYN 플래그 비트를 1로 설정한 세그먼트를 전송한다.
* 포트 상태 - A: CLOSED, B: LISTEN

2. B -> A: SYN + ACK
* SYN + ACK : 접속 요청을 받은 프로세스 B가 요청을 수락했으며, 접속 요청 프로세스인 A도 포트를 열어 달라는 메시지 전송
* 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, SYN과 ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
* 포트 상태 - B: SYN_RCV, A: CLOSED

3.  A -> B: ACK
* 포트 상태 - A: ESTABLISHED, B: SYN_RCV
* 마지막으로 접속 요청 프로세스 A가 수락 확인을 보내 연결을 맺음 (ACK)
* 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있다.
* 포트 상태 - A: ESTABLISHED, B: ESTABLISHED

## 4-way handshaking (연결 해제 과정)
* TCP의 연결을 해제(Connection Termination)하는 과정
![image](https://github.com/kmularise/TIL/assets/106499310/b976fbc4-53a0-4e60-977f-26e9e1a57fe1)
* 클라이언트(A)가 서버(B)에게 연결 해제를 요청
1. A -> B: FIN
* 프로세스 A가 연결을 종료하겠다는 FIN 플래그를 전송
* 프로세스 B가 FIN 플래그로 응답하기 전까지 연결을 계속 유지

2. B -> A: ACK
* 프로세스 B는 일단 확인 메시지를 보내고 자신의 통신이 끝날 때까지 기다린다.(이 상태가 TIME_WAIT 상태)
* 수신자는 Acknowledgement Number 필드를 (Sequence Number + 1)로 지정하고, ACK 플래그 비트를 1로 설정한 세그먼트를 전송한다.
그리고 자신이 전송할 데이터가 남아있다면 이어서 계속 전송한다.

3. B -> A: FIN
* 프로세스 B가 통신이 끝났으면 연결 종료 요청에 합의한다는 의미로 프로세스 A에게 FIN 프래그를 전송

4. A -> B: ACK
* 프로세스 A는 확인했다는 메시지를 전송

## TCP의 연결 설정 과정(3단계)과 연결 종료 과정(4단계)이 단계가 차이나는 이유?
클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 전송할 데이터가 남아 있을 수 있기 때문이다. 일단 클라이언트의 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후에 서버도 FIN 메시지를 보내기 때문이다.

## 만약 서버에서 FIN 플래그를 전송하기 전에 전송한 패킷이 라우팅 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생한다면?
이러한 현상에 대비하여 클라이언트는 서버로부터 FIN 플래그를 수신하더라도 일정시간(Default 240sec)동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.

## 초기 Sequence Number인 ISN을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?
연결할 때 사용하는 포트(Port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 숫자가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 수 있다.

