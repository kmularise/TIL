# 05. 객체 지향 설계 5원칙
## SOLID 다섯 가지 기본 원칙
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
2. OCP(Open Closed Principle) : 개방 폐쇄 원칙
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
5. DIP(Dependency Inversion Principle): 의존 역전 원칙

응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향 관점에서 재정립한 것이라 할 수 있다.

```
결합도와 응집도

좋은 소프트웨어 설계를 위해서는 결합도를 낮추고 응집도는 높이는 것이 바람직하다.
- 결합도 : 모듈(클래스) 간 상호 의존 정도, 결합도가 낮으면 모듈 간 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
- 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
- 결합도 수준 : 데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도
- 응집도 수준 : 기능 응집도, 순차 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도
```

## SRP - 단일 책임 원칙
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴
* 단일 책임 원칙은 속성, 메소드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있는 개념이다.
    * ex) 클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 갖게 한다.
* 객체 지향 4대 특성 중 모델링 과정을 담당하는 추상화와 가장 관계가 깊다.

[다양한 책음 가진 남자 클래스 - 단일 책임 원칙 적용 X]
<img width="518" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/8b0639f3-eb30-49f6-9b89-ce07e1987b8d">

[단일 책임 원칙을 적용해 남자 클래스를 단일 책임을 가진 여러 클래스로 분리]
<img width="923" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/9e3d871f-885f-49d2-be48-99d7d5812ed0">

## OCP - 개방 폐쇄 원칙
자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
> 소프트웨어 엔티티(클래스, 모듈 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. - 로버트 C.마틴

![image](https://github.com/kmularise/TIL/assets/106499310/66edf3bf-f4b6-4633-bf58-4d9e7f7e66ba)
* ex) 상위 클래스 또는 인터페이스를 중간에 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다. 다양한 자동차가 생기는 것은 자동 차 입장에서는 자신의 확장에는 개방돼 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄돼 있는 것이다.
* ex) JDBC와 자바 애플리케이션
* ex) 스프링 프레임워크
* 개방 폐쇄 원칙을 따르면 객체 지향 프로그래밍을 통해 유연성, 재사용성, 유지보수성 등을 얻을 수 있다.

## LSP - 리스코프 치환 원칙
하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
> 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. - 로버트 C. 마틴

* 상속의 조건과 리스코프 치환 원칙
    * 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
    * 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다.
    위 두개의 문장대로 구현된 프로그램이라면 리스코프 치환 원칙을 지켰다고 할 수 있다.

* 상위클래스는 메소드가 많을수록 좋다.
    * 풍성한 상위클래스는 빈약한 상위 클래스에 비해 사용 불가능한 경우나 불필요한 형변환이 없기 때문이다.

## ISP - 인터페이스 분리 원칙
> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다. - 로버트 C. 마틴

[인터페이스 분할 원칙을 적용한 남자 클래스]
<img width="933" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/186b87fe-e7e2-430a-8d31-770022762386">

* 단일책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두가지 다른 해결책
    * 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다.
    * 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.

* 인터페이스 최소주의 원칙
    * 인터페이스를 통해 메소드를 외부에 제공할 때 최소한의 메소드만 제공하라는 것
    * 인터페이스는 그 역할에 충실한 최소한의 기능만 공개해야 한다.

## DIP - 의존 역전 원칙
* 자신보다 변하기 쉬운 것에 의존하지 마라.
> 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다. 
> 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 자추 변경되는 구체(Concrete) 클래스에 의존하지 마라. - 로버트 C. 마틴
* 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위클래스, 인터페이스, 추상 클래스를 통해 의존해야 한다.
[의존 역전 원칙 적용 전 : 자주 변경되는 구체 클래스에 의존]

<img width="385" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/8b132e79-4f95-48d9-bab9-eefd5513a371">

[의존 역전 원칙 적용 후]

<img width="597" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/4931200c-cd08-488e-8abc-e4c60da20785">

의존 방향의 역전 : 기존에는 스노우타이어가 그 무엇에도 의존하지 않는 클래스였는데, 추상적인 타이어 인터페이스에 의존하게 되었다.

하나의 해결책을 찾으면 그 안에 여러 설계 원칙이 녹아있는 경우가 많다. 위에서는 개방 폐쇄 원칙도 반영되어 있다.

## SoC와 SOLID
* SoC(Seperation Of Concerns) : 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리
    * 하나의 속성, 하나의 메소드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다는 것
    * 관심사가 다르고 변화의 시기가 다르면 분리해야 한다.
* SoC를 적용하면 자연스럽게 단일 책임 원칙, 인터페이스 분리 원칙, 개방 폐쇄 원칙에 도달하게 된다.

## 정리
* SRP(단일 책임 원칙) : 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
* OCP(개방 폐쇄 원칙) : 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
* LSP(리스코프 치환 원칙) : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
* ISP(인터페이스 분리 원칙) : 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.
* DIP(의존 역전 원칙) : 자신보다 변하기 쉬운 것에 의존하지 마라.