# 03. 자바와 객체 지향
객체지향에서는 객체 단위의 프로그래밍이 가능하다.

## 객체 지향의 4대 특성 - 캡상추다
* 캡 - 캡슐화(Encapsulation): 정보 은닉(information hiding)
* 상 - 상속(~~Inheritance~~ extension에 가까움): 재사용 + 확장
* 추 - 추상화(Abstraction): 모델링
* 다 - 다형성(Polymorphism): 사용 편의
_____________________
## 클래스와 객체
* 클래스와 객체의 관계 - 분류(class)와 사물(object)의 관계
* 객체 : 세상에 존재하는 유일무이한 사물, 클래스의 인스턴스
* 클래스 : 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
________________________________
## 추상화
* 추상 : 공통되는 특성 / 공통 특성 추출
* 객체 지향의 추상화는 모델링이다.
* 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것
    * 추상화란 구체적인 것을 분해해서 관심영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = 모델링
* 모델 : 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현

```
컨텍스트(Context) : 애플리케이션 경계
-> "내가 창조하려는 세상은 어떤 세상인가?"
-> "내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?"
-> 필요한 특성만을 가지고 재조합
```
```
정리
- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 분류(class) : 사물 = 사람 : 김태희
- 클래스 설계에서 추상화가 사용된다.
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스다.
```
```
자바와 추상화, 클래스 객체
- 추상화 = 모델링 = 자바의 class 키워드
- 클래스와 객체 관계
    클래스 객체_참조_변수 = new 클래스();
    - 클래스의 인스턴스, 즉 객체를 생성하기 위해 객체 생성자 호출
    - 새로운 객체를 하나 생성해 그 객체의 주소값(포인터)을 객체 참조 변수에 할당
```

## 추상화와 메모리
```java
Mouse mickey 
// Mouse 객체에 대한 참조 변수 mickey를 만든다.
new Mouse()
// Mouse 클래스의 인스턴스를 만들어 힙에 배치한다.
대입문
// Mouse 객체에 대한 주소(포인터)를 참조 변수 mickey에 할당한다.
```
### 스태틱 영역(메소드 영역)
* 스태틱은 "고정된"이라는 뜻을 가지고 있는데, 스태틱 영역에 올라간 정보는 메인 메소드가 시작되기 전에 올라가서 메인 메소드가 종료된 후 내려올 정도로 스태틱 영역에 단단히 고정되어 있기 때문에 스태틱 영역이라고 한다.

## 클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버
* 정적 변수는 스태틱 영역에 저장공간을 갖게 된다.

### 정적 메소드
정적 메소드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메소드다. 정적멤버들은 객체가 아닌 클래스에 속해 있으며, 클래스는 JVM 구동 시 데이터 저장 영역의 스태틱 영역에 바로 배치되기 때문에 객체의 존재 여부에 관계 없이 쓸 수 있다.
* 메인 메소드는 정적 메소드여야 한다. 데이터 저장 영역이 초기화된 순간 객체는 하나도 존재하지 않기 때문에 객체 멤버 메소드를 바로 실행할 수 없기 때문이다.
* 실무에서는 클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메소드를 주로 정적 메소드로 구성한다.
## 정적 속성
* 정적 속성은 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보된다.
* 객체 속성은 속성명만 있고 실제 메모리 공간은 확보되지 않는다. 힙 영역에 객체가 생성되면 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당된다.

## 변수 정리
| 이름 | 다른 이름 | 메모리 할당 |
| --- | ---- | ---- |
| static 변수 | 클래스 [멤버] 속성, 정적 변수, 정적 속성, ... | 스태틱 영역 |
| 인스턴스 변수 | 객체 [멤버] 속성, 객체 변수, ... | 힙 영역 |
| local 변수 | 지역 변수 | 스택 영역(스택 프레임 내부) |

## 혼용되서 쓰이는 용어
* 클래스 멤버 = 정적 멤버 = 스태틱 멤버
* 객체 멤버 = 오브젝트 멤버 = 인스턴스 멤버
* 필드 = 속성 = 프로퍼티
* 함수 = 메소드
* 변수 공간 = 메모리 공간

__________________________________
## 상속 : 재사용 + 확장
![image](https://github.com/kmularise/TIL/assets/106499310/48f936ef-c6d7-4497-8889-241a2fbb98d3)
* 객체 지향에서 상속은 상위클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다. (확장, 세분화, 상위 클래스 - 하위 클래스, 슈퍼 클래스 - 서브 클래스, 상위 분류 - 하위 분류)
* 상위 클래스 쪽으로 갈수록 추상화, 일반화
* 하위 클래스 쪽으로 갈수록 구체화, 특수화

## 상속의 강력함
상위 클래스에서만 메소드를 구현해도 하위 클래스 객체에서 메소드를 사용할 수 있다.

## 상속은 is a 관계를 만족해야 한다? is a kind of 관계다.
* 상속 관계는 is a 관계로 많이 설명되고 있지만 더 명확한 표현이 있다.
* 하위 클래스 is a kind of 상위 클래스 : 하위클래스는 상위클래스의 한 분류다.

## 상속 정리
* 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
* 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
* 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

## 상속과 인터페이스
인터페이스는 be able to, 즉 "무엇을 할 수 있는" 이라는 표현 형태로 만드는 것이 좋다.
```
- 인터페이스 : 구현 클래스 is able to 인터페이스
- 해석 : 구현 클래스는 인터페이스 할 수 있다.
- 예제 : 고래는 헤엄칠 수 있다.
```
* 상위클래스는 물려줄 특성이 많을수록 좋고, 인터페이스는 구현을 강제할 메소드 개수가 적을수록 좋다. 

## 상속과 메모리
* 하위 클래스의 인스턴스가 생성될 때 상위클래스의 인스턴스도 함께 생성되고 힙 영역에 할당된다. 상위클래스 참조변수를 가지면 하위클래스에서만 독자적으로 있는 메소드는 사용하지 못한다.
_____________________________________
## 다형성 : 사용편의성
객체 지향에서 다형성이라고 하면 오버라이딩과 오버로딩이라고 할 수 있다.
물론 상위클래스와 하위 클래스 사이의 다형성, 인터페이스와 그것의 구현 클래스 사이의 다형성도 있다.
* 오버라이딩 : 같은 메소드 이름, 같은 인자 목록으로 상위클래스의 메소드를 재정의
* 오버로딩 : 같은 메소드 이름, 다른 인자 목록으로 다수의 메소드 중복 정의

오버로딩은 함수명 하나를 가지고 인자 목록을 달리할 수 있어 사용하기 편리하다. 특히 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다. 오버라이딩의 경우에도 하위클래스가 재정의한 메소드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경 쓰지 않아도 되고 깔끔한 코드를 유지할 수 있다.

## 다형성과 메모리
상위클래스 참조 변수를 사용해도 하위클래스에서 오버라이딩한 메소드는 하위클래스에서 재정의된 메소드가 호출된다.

[추가]

상위클래스 참조 변수를 사용하면 상위클래스의 메소드를 호출해야 되는데 어떠한 과정으로 하위클래스에서 오버라이딩한 메소드를 호출하게 되는 것일까?

그 이유는 자바의 모든 메소드는 가상메소드이기 때문이다.
* 가상메소드 : 메소드를 호출할 때, 실행시점에 호출된 객체의 타입을 보고 호출될 메소드를 결정하는 것, 가상메소드는 동적바인딩이다.
* 동적바인딩 : 실행시점에 결정하는 것
* 정적 바인딩 : 컴파일 시점에 정해지는 것
* 가상함수 테이블 : 클래스마다 존재하며 메소드 이름으로 최종적으로 오버라이드된 메소드 주소를 구할 수 있다. 하위클래스에서 오버라이딩이 일어났다면 상위클래스의 메소드 주소와는 다는 주소값을 저장하게 된다. 가상함수는 실행시점에 가상함수테이블을 이용해서 호출할 메소드를 결정한다.
_______________________________
## 캡슐화: 정보 은닉
* 접근 제어자
    * public : 모두가 접근 가능
    * protected : 상속 / 같은 패키지 내의 클래스에서 접근 가능
    * (default) : 같은 패키지 내의 클래스에서 접근 가능
    * private : 본인만 접근 가능
* 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 참조 변수를 이용해 접근해야 한다.
* 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
    * 일관된 형식으로 접근하기 때문
    * 메모리의 물리적 접근에 따른 이유도 있음
        * 클래스명.정적멤버는 바로 스태틱 영역을 참조할 수 있지만 객체참조변수명.정적멤버 형식으로 접근하면 인스턴스를 생성해서 힙영역을 참조하고 다시 스태틱 영역을 참조해야 하기 때문이다. 즉 클래스명.정적메버로 접근하는게 속도가 빠르다.

## 참조 변수의 복사
Call By Value와 Call By Reference는 본질적으로 차이가 없다. Call By Value에 의해 변수를 복사하든 Call By Reference에 의해 참조 변수를 복사하든 결국은 변수가 가진 값이 그대로 복사되기 때문이다. 다만 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석하는 반면, 객체 참조변수는 저장하고 있는 값을 주소로 해석한다는 차이가 있을 뿐이다.

[정리]
* 기본 자료형 변수는 값을 값 자체로 판단한다.
* 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
* 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
즉, 가지고 있는 값을 그대로 복사해서 넘겨 준다.

## 참고자료
* 가상메소드 관련 https://hyos-inside.tistory.com/m/46