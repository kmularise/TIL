# 

페이징을 통한 가상 메모리 관리

* 가상 메모리
    * 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    * 페이징, 세그멘테이션

## 페이징
* 외부 단편화가 발생하는 이유
    * 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.
* 프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당한다.
* 페이징(paging)
    * 프로세스의 논리 주소 공간을 페이지(page)라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법 

### 페이징에서의 스와핑
* 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 와웃(페이지 아웃)
* 메모리에 적재될 필요가 없는 페이지들을 보조기억장치로 스왑 아웃
* 실행에 필요한 페이지들은 메모리로 스왑 인

## 페이지 테이블
### 페이지 테이블이 필요한 이유
* 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일잉ㄹ이 알기 어렵다.
* 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU가 이를 순차적으로 실행시킬 수 없다.
* CPU는 다음에 실행할 명령어 위치를 찾기 어렵다.

### 페이지 테이블
* 실제 메모리 내 주소인 물리 주소가 불연속적으로 배치되더라도
* CPU가 참조하는 주소인 논리 주소는 연속적으로 배치되도록 하는 방법
* 페이지 번호화 프레임 번호를 짝지어 주는 일종의 이정표
* 프로세스마다 페이지 테이블이 있다.
* 물리적으로는 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보인다.
* CPU는 논리 주소를 순차적으로 실행하면 된다.

## 페이지 테이블의 문제점
### 내부 단편화
* 하나의 페이지 크기보다 작은 크기로 발생한다.


### 페이지 크기
```getconf PAGESIZE```

## PTBR
* 프로세스마다 페이지 테이블이 있고 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킨다.

## TLB
* TLB : CPU 옆의 페이지 테이블의 캐시 메모리
* 페이지 테이블의 일부를 가져와서 저장한다.
* CPU가 접근하려는 논리주소가 TLB에 있다면? TLB 히트
    * 메모리 접근 1번
* CPU가 접근할겨는 노리주소가 TLB에 있다면? TLB 미스
    * 메모리 접근 2번

## 페이징에서의 주소 변환
