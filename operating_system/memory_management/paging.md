# 

페이징을 통한 가상 메모리 관리

* 가상 메모리
    * 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
    * 페이징, 세그멘테이션

## 페이징
* 외부 단편화가 발생하는 이유
    * 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다.
* 프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당한다.
* 페이징(paging)
    * 프로세스의 논리 주소 공간을 페이지(page)라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법 

### 페이징에서의 스와핑
* 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 와웃(페이지 아웃)
* 메모리에 적재될 필요가 없는 페이지들을 보조기억장치로 스왑 아웃
* 실행에 필요한 페이지들은 메모리로 스왑 인

## 페이지 테이블
### 페이지 테이블이 필요한 이유
* 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일잉ㄹ이 알기 어렵다.
* 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU가 이를 순차적으로 실행시킬 수 없다.
* CPU는 다음에 실행할 명령어 위치를 찾기 어렵다.

### 페이지 테이블
* 실제 메모리 내 주소인 물리 주소가 불연속적으로 배치되더라도
* CPU가 참조하는 주소인 논리 주소는 연속적으로 배치되도록 하는 방법
* 페이지 번호화 프레임 번호를 짝지어 주는 일종의 이정표
* 프로세스마다 페이지 테이블이 있다.
* 물리적으로는 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보인다.
* CPU는 논리 주소를 순차적으로 실행하면 된다.

## 페이지 테이블의 문제점
### 내부 단편화
* 하나의 페이지 크기보다 작은 크기로 발생한다.


### 페이지 크기
```getconf PAGESIZE```

## PTBR
* 프로세스마다 페이지 테이블이 있고 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킨다.

## TLB
* TLB : CPU 옆의 페이지 테이블의 캐시 메모리
* 페이지 테이블의 일부를 가져와서 저장한다.
* CPU가 접근하려는 논리주소가 TLB에 있다면? TLB 히트
    * 메모리 접근 1번
* CPU가 접근할겨는 노리주소가 TLB에 있다면? TLB 미스
    * 메모리 접근 2번

## 페이징에서의 주소 변환
* 특정 주소에 접근하고자 할 때 필요한 정보
    * 어떤 페이지 또는 프레임에 접근하고 싶은지(page number)
    * 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지 (offset)
* 페이징 시스템에서의 논리 주소
    * 페이지 번호(page number)와 변위(offset)
    * <페이지 번호, 변위>로 이루어진 논리 주소는 페이지 테이블을 통해 <프레임 번호, 변위>로 변환된다.

## 페이지 테이블 엔트리
* 페이지 테이블의 각각의 행: 페이지 테이블 엔트리(PTE)
    * 현재까지 설명한 PTE: 페이지 번호, 프레임 번호
    * 유효비트 : 현재 해당 페이지에 접근 가능한지 여부
        * 1 : 메모리에 적재된 페이지
        * 0 : 메모리에 없고 스왑 영역에 있는 페이지
        * 유효 비트가 0인 페이지에 접근하려고 하면?
            * 페이지 폴트(page fault)라는 인터럽트 발생
                1. CPU는 기존의 작업 내역을 백업한다.
                2. 페이지 폴트 처리 루틴을 실행한다.
                3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
                4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근할 수 있게 된다.
    * 보호비트 : 페이지 보호 기능을 위해 존재하는 비트, 페이지에 접근할 권한을 제한한다.
    * 참조비트 :
        * CPU가 이 페이지에 접근한 적이 있는지 여부
    * 수정비트 :
        * CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
        * 수정된 페이지는 스왑 아웃될 때 보조기억장치에도 쓰기 작업을 거쳐야 한다.
    

