# 데드락(deadlock, 교착상태)

## 데드락이란?
- 일어나지 않을 사건을 기다리며 진행이 멈춰버리는 현상
- 일련의 프로세스나 스레드들이 서로가 가진 자원을 기다리며 잠들어 있는(blocked) 상태

<br>
<br>

## 자원 할당 그래프

교착 상태 발생 조건을 파악할 수 있다.
<br>

* 어떤 프로세스 또는 스레드가 어떤 자원을 할당 받아 사용 중인지 확인 가능하다.
* 어떤 프로세스 또는 스레드가 어떤 자원을 기다리고 있는지 확인 가능하다.

ex)


![image](https://github.com/kmularise/TIL/assets/106499310/118bbe3c-359c-4eec-bb70-5b94c6ade7da)


## 데드락 발생 조건
아래의 네가지 조건 중 하나라도 만족하지 않으면 교착 상태가 발생하지 않는다.
1. 상호 배제
2. 비선점
3. 점유와 대기
4. 순환 대기

### 1. 상호 배제(Mutual exclusion)
- 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
- 매 순간 하나의 프로세스만이 자원을 사용할 수 있다.
### 2. 비선점
- 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않는다.
- 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 상태
### 3. 점유와 대기
- 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태
- 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있다.
### 4. 순환 대기
- 프로세스들이 원의 형태로 자원을 대기하는 상태
- 자원을 기다리는 프로세스 간에 사이클이 형성되어야 한다.
- ex)
```
프로세스 P0, P1, …., Pn이 있을 때        

P0은 P1이 가진 자원을 기다림
P1은 P2가 가진 자원을 기다림
...
Pn-1은 Pn이 가진 자원을 기다림
Pn은 P0이 가진 자원을 기다림
```

## 교착상태 해결 방법
- 예방(Deadlock Prevention)
    - 교착 상태가 발생하지 않도록 하는 것
    - 자원 할당 시 교착상태의 4가지 발생 조건(상호 배제, 비선점, 점유와 대기, 순환 대기) 중 어느 하나가 만족되지 않도록 하는 것
- 회피(Deadlock Avoidance)
    - 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당
    - 시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당
- 검출 후 회복(Deadlock Detection and recovery)
    - Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견 시 recover
- 교착 상태 무시(Deadlock Ignorance)
    - 교착상태를 시스템이 책임지지 않음
    - Unix를 포함한 대부분의 OS가 채택
### 예방(Deadlock Prevention)

- 상호배제(Mutual Exclusion)
    - 공유해서는 안되는 자원의 경우 반드시 성립해야 함 → 모든 걸 hold하고 시작
- 점유와 대기(Hold and Wait)
    - 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분
    
    → 자원의 활용률을 낮출 수 있는 방식
    
    - 방법 1.  프로세스 시작 시 모든 필요한 자원을 할당 받게 하는 방법 - 이미 hold한 자원도 뱉어놓고 시작 preemption
    - 방법 2. 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청
- 비선점(No Preemption)
    - 선점이 가능한 자원(e.g. CPU)에 한해 효과적
    
    → 모든 자원이 선점 가능한 것은 아니다. I/O 장치의 경우에는 적용하기 어렵다. (e.g. 프린터)
    
    - 프로세스가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨
    - 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.
    - State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용(CPU, memory)
- 순환 대기(Circular Wait)
    - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당
    - 자원에 번호를 붙이고 오름차순으로 할당하면 원행 대기는 발생하지 않는다.
        - 예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원 Ri을 할당받기 위해서는 우선 Ri를 release해야 한다.
    
    → Utilization(자원의 이용률) 저하, throughout 감소,  starvation 문제
    
    → 자원에 번호를 붙이는 것은 어려운 작업
    
    → 어떤 자원에 어떤 번호를 붙이느냐에 따라 활용률이 달라진다.


### 회피(Deadlock Avoidance)

- 교착 상태를 무분별한 자원 할당으로 인해 발생했다고 간주
- 교착 상태가 발생하지 않을 만큼 할당
    - 자원 요청에 대한 부가정보를 이용해서 자원 할당이 교착상태로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당
    - 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 자원별 최대 사용량을 미리 선언하도록 하는 방법임
- 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 만큼만 자원 배분

### 교착 상태 검출 후 회복(Deadlock Detection and Recovery)
- 교착 상태의 발생을 인정하고 사후에 조치하는 방식
- 프로세스가 자원을 요구하면 일단 할당, 교착 상태가 검출되면 회복
- **선점을 통한 회복, 프로세스 강제 종료를 통한 회복**

#### 1. 교착 상태 검출(Deadlock Detection)

- Resource type 당 single instance인 경우
    - 자원할당 그래프에서의 cycle이 곧 deadlock을 의미
- Resource type 당 multiple instance인 경우
    - Banker’s algorithm과 유사한 방법 활용
- Wait-for graph 알고리즘
    - Resource type 당 single instance인 경우
    - Wait-for graph
        - 자원할당 그래프의 변형
        - 프로세스만으로 node 구성
        - Pj가 가지고 있는 자원을 Pk가 기다리는 경우 Pk→Pj
    - Algorithm
        - Wait-for-graph에 사이클이 존재하는지를 주기적으로 조사
        - O(n^2) (너비우선탐색, 깊이 우선 탐색)
#### 2. 회복 (Recovery)

- 프로세스 강제 종료를 통한 회복(Process termination)
    - 교착 상태에 놓인 프로세스를 모두 강제 종료(Abort all deadlocked processes) → 작업 내역을 잃을 위험
    - 교착 상태가 해결될 때까지 한 프로세스씩 강제 종료(Abort one process at a time until the deadlock cycle is eliminated) → 오버헤드
- 선점을 통한 회복(Resource Preemption)
    - 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
    - 비용을 최소화할 victim의 선정
    - 안전 상태(safe state)로 롤백하여 프로세스를
    - Starvation 문제
        - 동일한 프로세스가 계속해서 victim으로 선정되는 경우
        - cost factor에 rollback 횟수도 같이 고려

### 교착 상태 무시(Deadlock Ignorance)
- 교착상태는 일어나지 않는다고 생각하고 아무런 조치도 취하지 않음
    - 교착상태는 매우 드물게 발생하므로 교착상태에 대한 조치 자체가 더 큰 오버헤드일 수 있음
    - 만약 시스템에 교착상태가 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처
    - UNIX, Windows 등 대부분의 범용 OS가 채택
