# 뮤텍스와 세마포어
프로세스 동기화는 공유 데이터의 일관성을 유지하는데 중요한 역할을 한다. 임계 영역(critical section)을 처리하기 위한 해결 방법으로 소프트웨어적으로 처리하는 방법과 하드웨어적으로 처리하는 방법이 있다.

소프트웨어적으로 처리하는 방법으로는 세마포어, 뮤텍스가 있다.

<br/><br/>

## 뮤텍스(Mutex)

![image](https://github.com/user-attachments/assets/dfe2b34a-16cd-4d14-822b-23bccda8566b)

- 단일 스레드/프로세스만이 공유 자원에 접근할 수 있도록 하는 기법
- 공유 자원을 사용하기 전에 락을 걸고, 사용한 후 락을 해제(UNLOCK)한다.

<br/><br/>

## 세마포어(Semaphore)

![image](https://github.com/user-attachments/assets/a7a73915-7fda-4d58-b2ba-2c230798ed3b)

- 하나 이상의 프로세스/스레드가 임계 영역에 접근할 수 있도록 하는 장치
- 공유자원에 접근할 수 있는 자원의 최댓값을 나타내는 정수값을 이용해 상호배제를 달성한다.
    - 최대 허용치만큼 사용자가 동시에 접근할 수 있으며, 각 프로세스는 세마포어의 값을 확인하고 변경할 수 있다.
- `wait()` 과 `signal()` 함수를 이용해서 세마포어에 접근할 수 있다.

<br/><br/>

## 뮤텍스와 세마포어 차이
세마포어와 뮤텍스의 차이점은 기본적으로 세마포어는 시그널링 메커니즘이고 뮤텍스는 락 메커니즘이라는 것이다. 즉, 프로세스가 공유자원을 획득하려고 하면 세마포어의 wait()연산을 실행시키고, 세마포어의 값을 하나 감소시킨다. 만약에 프로세스가 공유자원을 해제하면 signal() 연산을 실행시키고 세마포어의 값을 하나 증가시킨다. 세마포어 계수(count)가 0이되면 모든 공유자원들이 프로세스들에 의해 점유되게 된다. 
세마포어 계수(count)가 0일 때, 프로세스가 자원을 획득하려고 하면, wait()를 실행시키고 세마포어 카운트가 0보다 커질때까지 blocked 상태가 된다.

<br/><br/>

| 비교 | 세마포어 | 뮤텍스 |
| ----------------------- | ------ | ------ |
| 메커니즘 | 세마포어는 시그널링 메커니즘이다. | 뮤텍스는 잠금 메커니즘이다. |
| 변수 | 세마포어는 정수 변수이다. | 뮤텍스는 Object이다. |
| 기능 | 세마포어는 여러 프로세스가 여러 유한한 자원에 액세스할 수 있게 한다. | 뮤텍스는 여러 프로세스가 단일 리소스에 액세스할 수 있지만 동시에 수행할 수 없게 한다. |
| 소유권 | 세마포어 값은 자원을 얻거나 해제하는 프로세스에 의해 변경 될 수 있다. | 뮤텍스 Lock은 반드시 획득한 프로세스에 의해서만 해제된다. |
| 분류 | 세마포어는 계수형(count) 세마포어와 바이너리 세마포어로 분류된다. | 더 이상의 분류는 없다. |
| 연산 | 세마포어 값은 wait() 및 signal() 연산을 사용하여 수정된다. | 리소스를 요청하거나 해제하는 프로세스에 의해 Lock&Unlock이 된다. | 
| 리소스 | 모든 리소스가 사용 중이면 리소스를 요청하는 프로세스는 wait() 작업을 수행하고 대기큐에 들어가 있으면서 세마포어 값이 1이상이 될때 다른 프로세스에 의해 wakeup한다. | Lock이 걸려있으면 Lock의 소유 프로세스가 잠금을 풀때까지 프로세스가 대기하고 있는다.(바쁜 대기) |


## 참고자료
https://techdifferences.com/difference-between-semaphore-and-mutex.html
https://techdifferences.com/difference-between-semaphore-and-monitor-in-os.html
https://os.mbed.com/docs/mbed-os/v6.16/apis/mutex.html
https://os.mbed.com/docs/mbed-os/v6.16/apis/semaphore.html
