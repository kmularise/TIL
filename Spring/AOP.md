# AOP
### 프록시와 프록시 패턴, 데코레이터 패턴
* 프록시 패턴 :  프록시의 접근 제한을 살리기 위한 패턴(캐싱, 지연 로딩, 권한 관리 등)
* 데코레이터 패턴 : 프록시의 부가 기능을 살리기 위한 패턴(로그 추적기, 시간 추적기 등)
    * 프록시는 핵심 기능 뿐만 아니라 핵심기능도 수행 가능

## AOP 특징
### 다이내믹 프록시
* 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용
### 프록시 팩토리 빈
* 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입
* 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능의 적용을 결정하는 알고리즘을 담은 포인트컷이 프록시에서 분리될 수 있었다.
![image](https://github.com/kmularise/TIL/assets/106499310/58f2d2cc-d049-4709-84a9-3904b9e8c2e3)

## AOP : 애스펙트 지향 프로그래밍(Aspect Oriented Programming)
핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 설계하고 개발하는 방법
* 에스펙트(Aspect)
    * 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소
    * 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.
* 에스펙트(Aspect) = 어드바이스(Advice) + 포인트컷(PointCut)
    * 어드바이스 : 부가 기능을 정의한 코드
    * 포인트컷 : 어디에 적용할지 결정

## AOP 적용 기술
### 프록시를 이용한 AOP : 스프링 AOP
* 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만들었다.
* 프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가기능을 제공해주게 되어 있다.
* 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 프록시 적용
### 바이트코드 생성과 조작을 통한 AOP : AspectJ
* AspectJ는 스프링처럼 다이내믹 프록시 방식을 사용하지 않는다.
* AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 고쳐서 부가 기능을 직접 넣어주는 방법을 사용한다.
* 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.

* 장점 :
    * 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다.
    * 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다. 프록시를 AOP의 핵심 메커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한된다. 하지만 바이트 코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가 기능을 부여해 줄 수 있다.
* 단점 :
    * 자바 관련 설정(특별한 컴파일러, AspectJ 전용 문법, 자바 실행 옵션)이 복잡하다.

> 바이트 코드 조작 : 개발자의 소스코드(.java)를 직접 수정하지 않고 .class 파일을 수정하여 원하는 기능 구현
<!-- https://joon2974.tistory.com/22 -->
<!-- https://jungkeung.tistory.com/153 -->
<!-- https://iyk2h.tistory.com/377 -->