# 예외
## 예외의 종류와 특징
![image](https://github.com/kmularise/TIL/assets/106499310/42e4754d-fd22-4754-9b5d-e7ef87ef4e10)
### Error
* java.lang.error를 상속한 하위 클래스
* 시스템에 문제가 있을 때 발생하는 예외
* 복구 불가능한 시스템 레벨의 문제이므로, catch로 잡아서 할 수 있는 것이 없다.
* OutOfMemorryError, ThreadDeath 등이 있다.
* 시스템 레벨의 작업을 하는게 아니라면 신경쓰지 않아도 된다.

### Checked Exception
* Exception을 상속하면서 RuntimeException을 상속하지 않은 예외를 말한다.
* 컴파일러가 예외 처리를 확인한다.

### Unchecked Exception
* Exception을 상속하면서 RuntimeException을 상속한 예외
* 예외처리가 강제되지 않는다. 컴파일러가 예외처리를 확인하지 않는다.

## 예외 처리 방법
### 예외 복구
* 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는다.
* 사용자에게는 원하는 기능이 의도치 않게 동작하는 예외적 상황이지만, 어플리케이션의 입장에선 정상적인 흐름을 해치지 않도록 한다.

### 예외처리 회피
* 예외를 직접 처리하지 않고 자신을 호출한 메서드에 예외를 던지는 방법
* 어떤 오브젝트가 어떤 예외를 다루어야 하는지 명확한 설계를 기반으로 확실한 의도로 수행하여야 한다. 기계적으로 throws Exception 하지 말아야 한다.

### 예외 전환
* 예외 회피와 유사하지만, 다른 예외로 적절하게 전환해서 던진다.
* 내부에서 발생한 예외를 명확한 상황의 예외로 바꿔서 던지는 것이다. 

## 예외처리의 전략
### 런타입 예외의 보편화
* Checked Exception은 사용자에게 발생할 수 있는 문제를 코드 상에서 알릴 수 있다는 장점이 있다.

하지만 여러가지 단점이 있다.
* API에 Checked Exception이 있으면 사용자는 예외처리 하느라 번거롭다.
* 최근 자바 엔터프라이즈 서버 환경에선 작업을 중단하지 않도록 처리할 이유가 없다. 각각의 요청이 독립적인 작업이기 때문에, 해당 작업에 문제가 있다면 해당 작업만 그만두면 된다.
* 로우레벨에서 발생한 예외가 웹 컨트롤러까지 전달한다 해도, 사용자와 직접 커뮤니케이션하면서 예외 상황을 복구할 수 있는 상황은 자바 엔터프라이즈 어플리케이션에서 쉽게 있을 수 없다.
* 대부분의 체크 예외는 대부분 복구가 불가능한 상황이기에 런타임 예외로 전환해서 던진다.
    * 복구 불가능한 상황에 불필요한 try catch 블록 사용을 줄이고, 로우레벨의 예외를 의미가 있는 예외로 바꿔 던진다.

### 애플리케이션 예외 : Checked Exception 강제
* 애플리케이션 로직에서 의도적으로 발생시키고 예외 처리를 하도록 요구하는 설계
    * ex) 은행 서버 개발 시, 잔고 부족 시 발생하는 InsufficientBalacneException은 Checked Exception으로 예외 처리 강제
    * 비즈니스 로직에서 절대로 발생하면 안되기에 Checked Exception으로 예외처리를 강제

