# 서비스 추상화(PSA, Portable Service Abstractions)
* 하위 시스템의 공통점을 뽑아내서 분리시키는 것
* 서비스 추상화를 통해 단일책임원칙을 준수할 수 있다.

## 단일 책임 원칙과 DI
* 객체는 단 하나의 책임만 가져야 한다.
* 어떤 변경이 필요할 때 수정 대상이 명확해진다.
    * 트랜잭션 기술이 바뀌면 기술 추상화 계층의 설정만 바꿔주면 되고, 데이터를 가져오는 테이블이 바뀌었다면 데이터 액세스 로직을 담고있는 UserDao만 변경하면 된다.
    * 레벨 관리 정책이 바뀌면 UserService만 변경하면 된다.
* 이러한 구조를 만들기 위해선 스프링 DI를 이용하면 좋다.
    * 인터페이스의 도입과 적절한 DI는 단일 책임 원칙 뿐 아니라 개방 폐쇄 원칙도 잘 지키게 된다.
    * 결합도가 낮아 변경에 유연하며, 단일 책임에 집중하는 응집도 높은 코드를 개발할 수 있다.

## 트랜잭션 서비스 추상화
* 스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다.
* 이를 통해 각 기술의 트랜잭션 API를 이용하지 않아도, 일관된 방식으로 트랜잭션을 제어하는 경계설정 코드를 작업할 있다.
![image](https://github.com/kmularise/TIL/assets/106499310/34e0b93e-08d2-4ffb-8c69-c996406bc5fa)

## 메일 서비스 추상화
### 메일 발송 테스트
* 테스트 코드를 실행할 때마다 메일이 발송되게 하면 다음과 같은 문제점이 있다.
    1. 메일 발송이란 부하가 큰 작업 : 유료 메일서버나 실제 운영중이 메일 서버를 사용한다면 해당 서버에 상당한 부담을 줄 수 있다.
    2. 실수로 인한 메일 발송 : 테스트 메일을 실 사용자에게 발송할 수 있다.
    3. 테스트 속도 저하 : 메일 발송이 많다면, 테스트도 느려질 수 있다.
* 메일 전송 요청은 받되 메일 발송은 되지 않도록 하는 것이 좋다.
### JavaMail의 문제점
* JavaMail은 클래스라 구현부를 바꿀 수 없다. 메일 발송 시 사용하는 객체들의 선언 타입이 인터페이스가 아닌 클래스다.
* 확장이나 지원이 불가능하다.

### MailSender
*  메일 전송 기능을 추상화해서 인터페이스를 적용하고 DI를 통해 분리

## 테스트 대역
![image](https://github.com/kmularise/TIL/assets/106499310/e7d34097-8f9d-423c-8295-9293981121a4)

* 테스트의 범위 : 특정 클래스를 테스트하는 클래스의 관심사는 오로지 특정 클래스의 로직이어야 한다.
    * ex) UserServiceTest 클래스의 관심사는 오로지 UserService 클래스의 로직이어야 한다.
* 테스트 대상 오브젝트에는 여러 의존 오브젝트들이 있을 수 있다.
* 의존 오브젝트에 대한 '대역' 역할을 하는 오브젝트를 만들어 테스트가 이상없이 동작되도록 해야한다. 이러한 오브젝트들을 테스트 대역(test double) 이라고 한다.
### Stub
* Dummy 객체가 실제로 동작하는 것처럼 구현하는 테스트 대역
* 반환 값이 있거나 예외를 테스트해야 할 경우 사용한다.

### Mock
* 가짜 객체를 만든 후 Stubbing을 통해 미리 명세를 정의해 놓은 대역
* Stub와 다른 점은 메서드의 리턴 값으로는 판단할 수 없는 행위를 검증한다.

## 참고 자료
* https://khalilstemmler.com/wiki/test-doubles/
* https://yangbongsoo.gitbook.io/study/spring-1/service_abstraction
<!--
https://tlatmsrud.tistory.com/109
-->