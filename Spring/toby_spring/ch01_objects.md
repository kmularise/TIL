# 오브젝트와 의존관계
오브젝트의 설계와 구현, 동작 원리

* 스프링은 자바를 기반으로 한 기술
* 자바 - 객체지향 프로그래밍이 가능한 언어
* 스프링이 가장 관심을 많이 두는 대상 : 오브젝트
    * 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고 소멸하기까지의 전 과정을 주목해야 한다.
    * 오브젝트의 설계, 만들어지는 단위, 오브젝트가 자신의 존재를 드러내고 등장하는 과정을 살펴봐야 한다.
    * 오브젝트의 설계와 구현
        * 객체지향 설계
        * 디자인 패턴 : 다양한 목적을 위해 재활용 가능한 설계 방법
        * 리팩토링 : 좀 더 깔끔한 구조가 되도록 지속적으로 개선해 나가는 작업
        * 단위 테스트 : 오브젝트가 기대한 대로 동작하고 있는지 효과적으로 검증
    * 스프링은 오브젝트의 설계, 구현, 사용, 개선에 관련하여 명쾌한 기준을 마련해준다.


[DAO(Data Access Object)]
데이터베이스를 사용해 데이터를 조회하거나 변경하는 기능을 전담하는 오브젝트

[자바 빈(Java Bean)]
* 원래는 비주얼 툴에서 조작 가능한 컴포넌트였으나 이런 형태로는 요새 잘 안 쓴다.
* 이제는 다음 두가지 관례를 따라 만들어진 오브젝트
    1. 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
    2. 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성, 프로퍼티는 setter와 getter를 이용해 수정 또는 조회할 수 있다.

[JDB를 이용하는 작업의 일반적인 순서]
* DB 연결을 위한 Connection을 가져온다.
* SQL을 담은 Statement(또는 PreparedStatement)를 만든다.
* 만들어진 Statement를 실행한다.
* 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨 준다.
* 작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아 준다.
* JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.


## DAO의 분리 - 관심사의 분리
* 오브젝트에 대한 설계와 이를 구현한 코드가 변할 수 밖에 없다.
    * 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.
    * 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고, 운영되는 환경도 변화한다. 
* 미래의 변화를 대비한 설계 : 분리와 확장을 고려한 설계가 필요하다.

[분리]
* 모든 변경과 발전은 한 번에 한가지 관심사항에 집중해서 일어난다.
-> 한 가지 관심이 한 군데에 집중되게 하는 것이다.
* 관심사의 분리 : 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

## 커넥션 만들기의 추출 - 중복 코드의 메소드 추출
* getConnection() 메소드를 따로 추출해서 DB 연결 기능을 구현하였다.
* DB종류와 접속 방법이 바뀌어서 드라이버 URL이 바뀌었다거나, 로그인 정보가 변경되어도 getConnection() 메소드만 수정하면 된다.

## 변경사항에 대한 검증 : 리팩토링과 테스트
* 리팩토링 : 기능 변경은 없지만 코드 구조와 구현 방법을 변경해 코드를 깔끔히 하는 것
* 테스트 : 리팩토링한 코드가 제대로 동작하는지에 대해 피드백을 준다.

[리팩토링]
* 기존의 코드를 외부의 동작방식과 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
* 효과 : 내부의 설계 개선, 코드 가독성 용이해짐, 변화에 효율적으로 대응 -> 유지보수 용이, 견고하면서 유연한 제품 개발

## DB 커넥션 만들기의 독립 - 상속을 통한 확장, 템플릿 메소드 패턴, 팩토리 메소드 패턴
[상황]
* N사와 D사가 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법 적용하고 싶어하는 상황
* DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있음

[해결]
### 1. 템플릿 메소드 패턴
* 템플릿 메소드 패턴 : 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법
![image](https://github.com/kmularise/TIL/assets/106499310/220a6fd8-5d61-47a6-b11a-c1ba0d64094a)
* 템플릿 메소드에서 호출하는 추상 메소드 : UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들어 놓음
* UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브 클래스를 만들고, 각각의 서브클래스에서 추상 메소드로 선언했던 getConnection() 메소드 구현
* 클래스 레벨 구분 : 두 개의 관심이 독립적으로 분리
    * UserDao : 어떻게 데이터를 등록하고 가져올 것인가
    * NUserDao, DUserDao : DB 연결 방법을 어떻게 할 것인가


### 2. 팩토리 메소드 패턴
* 팩토리 메소드 패턴 : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정
![image](https://github.com/kmularise/TIL/assets/106499310/af6b850d-4cf2-49e5-92f3-f99898171c2a)
* UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다. 그저 Connection 인터페이스에 정의된 메소드를 사용할 뿐이다.
* NUserDao나 DUserDao에서는 어떤 식으로 Connection 기능을 제공하는지, 어떤 방법으로 Connection 오브젝트를 만들어내는지에 대해 관심을 두고 있다.

### 디자인 패턴
* [템플릿 메소드 패턴 참고](../..//OOP/OOPandSpring/chap06.md#%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4template-method-pattern)
* [팩토리 메소드 패턴 참고](../../OOP/OOPandSpring/chap06.md#%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4factory-method-pattern)

### 상속을 통한 확장의 단점
* 자바는 다중 상속을 허용하지 않으므로 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.
* 상속을 통한 상하위 클래스의 관계는 밀접하다.
    * 하위클래스는 상위클래스의 기능을 직접 사용할 수 있다.
    * 상위클래스의 내부의 변경이 있을 때 모든 하위 클래스를 함께 수정하거나 개발해야 할 수도 있다.
* 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다. 

## DAO 확장 


## 클래스의 분리
* 상속관계도 아닌 완전히 독립적인 클래스로 분리
![image](https://github.com/kmularise/TIL/assets/106499310/a02e9439-d067-4fee-9c80-57fd9c7671e0)

[문제점]
* N사와 D사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용했던 것이 불가능해졌다.
    * UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문
    * 다른 방식으로 DB 커넥션을 제공하는 클래스를 사용하기 위해선 UserDao 소스코드를 직접 수정해야 함
* DB 커넥션을 제공하는 클래스가 어떤 것인지 UserDao가 구체적으로 알고 이어야 한다.
    * UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문
    * UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버린다.

## 인터페이스 도입
* 추상적인 느슨한 연결고리 형성 : 인터페이스 도입
![image](https://github.com/kmularise/TIL/assets/106499310/87cdeac0-5c23-43c4-a674-8d9063ae1c77)

* UserDao가 인터페이스를 사용하게 한다면 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 가지고, 그 기능을 어떻게 구현했는지는 관심을 둘 필요가 없다.

[문제점]
* UserDao 코드에 DConnection 클래스 생성
## 관계 설정 책임의 분리

