<!-- ## 인터페이스를 통한 분리
* 같은 클래스의 코드이지만 책임이 다른 코드는 직접 접근하지 않고 인터페이스를 통해 간접적으로 사용 -->

## 7.1 SQL과 DAO의 분리
* SQL을 DAO에서 분리하기
    * 운영 중에 DB의 테이블 또는 필드이름, SQL문이 변경될 수 있는데, 그 때마다 DAO를 수정해서 다시 컴파일하기에는 무리가 있기 때문이다.
*  SQL을 DAO에서 분리하는 방식
    1. XML 설정을 이용한 분리: SQL을 XML 설정파일의 프로퍼티 값으로 정의해서 DAO에 주입함
        1) 개별 SQL프로퍼티 방식
        2) SQL 맵 프로퍼티 방식
        - 문제점 : 
            * 데이터 액세스 로직의 일부인 SQL과 애플리케이션 구성정보를 가진 DI설정정보가 섞여있다.
            * 꼭 XML 아니고 다른 포맷 파일에 저장할 수 있으면 사용 및 관리가 편하다.
            * SQL이 스프링 설정파일로부터 생성되면 런타임에 변경이 어렵다.
    2. SQL 제공 서비스 인터페이스 구현
        * XML 방식의 문제점을 해결하기 위해, DAO가 사용할 SQL을 제공해주는 기능을 독립
        * 인터페이스 제공 : SQL에 대한 키 값을 전달하면 그에 해당하는 SQL을 돌려주는 메소드 제공
        > 모든 DAO는 sql을 어디에 저장해두고 가져오는지에 대해 신경쓰지 않아도 되고 그저 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다. SqlService도 DAO에 영향을 주지 않고 다양한 방법으로 구현할 수 있다.

## 7.2 인터페이스의 분리와 자기참조 빈
* 7.1-2의 2. SQL 제공 서비스 인터페이스 구현 발전시키기
### XML 파일 매핑
* SQL을 저장해두는 독립적인 파일을 이용
* JAXB : XML에 담긴 정보를 파일에서 읽어오는 방법 중 하나
    * XML 정보를 오브젝트처럼 다룰 수 있어 편리하다.
    * 언마샬링(unmarchalling) : XML to 자바 오브젝트
    * 마샬링 : 자바 오브젝트 to XML
    * SQL 맵 XML과 SQL 맵을 위한 스키마를 JAXB 컴파일러로 컴파일하면, 바인딩용 클래스가 생성된다.
* 언제 JAXB를 사용해 XML문서를 가져올까?
    * DAO가 SQL을 요청할 때마다 매번 XML 파일을 다시 읽는건 비효율적이다.
        * 한번 읽은건 어딘가에 저장해두고 DAO에서 요청이 올 때 사용해야한다.
    * 우선은 SQL 읽기 작업은 XmlSqlService 생성자에서 동작하게끔 만든다.
        * 변환된 SQL오브젝트는 맵에 저장해놨다가 DAO요청이 오면 전달하는 방식으로 구현
### 빈의 초기화 작업
* SQL 읽기 작업은 XmlSqlService 생성자에서 할 때 문제점
    * 생성자에서 예외가 발생할 수 있는 복잡한 초기화 작업을 다루는건 좋지 않다.
    * 읽어 들일 파일 위치, 이름이 고정되어 있음
* 대안 
    * 생성자 대신에 loadSql()처럼 초기화 메서드를 사용하고, 파일이름과 위치는 외부에서 DI로 설정
    * @PostConstruct 애노테이션을 통해 초기화 메소드로 지정
        * 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행되게끔 해주므로, XmlSqlService의 sqlmapFile프로퍼티 값이 주입되고 나서 해당 xml파일을 읽는 로직이 수행될 수 있다.

### 변화를 위한 준비: 인터페이스 분리
* 위의 방식에서 문제점
    * SQL을 가져오는 방법이 특정 기술에 고정되어있다. 다른 포맷의 파일에서 읽어와야하는 요구사항이 생기면 XmlSqlService를 직접 수정해야한다.
    * 가져온 SQL정보를 새로운 방식으로 저장하고 검색해서 가져오려면 XmlSqlService를 직접 수정해야한다.
* 분리 가능한 관심사를 나눠서 독립적인 책임을 뽑아 보기
    1. SQL 정보를 외부 리소스로부터 읽어오는 책임
    2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공하는 책임
    3. 한번 가져온 SQL을 필요에 따라 수정

![image](https://github.com/kmularise/TIL/assets/106499310/dced0a82-fcc9-492b-b46c-775b67f07936)

* 문제점
    * 위 그림처럼 SqlService가 SqlReader에게 데이터를 달라고 요청하고, 그것을 다시 SqlRegistry에 전달하는 방식은 불필요하게 service를 거치게 된다.
    * SqlReader에게 SqlRegistry 오브젝트를 전달해서 저장하라고 요청하는게 좋다. SqlRegistry가 일종의 콜백 오브젝트처럼 사용된다.
    ```java
    sqlReader.readSql(sqlRegistry);
    ```

### 자기참조 빈으로 구현
* 책임에 따라 분리되지 않았던 XmlSqlService 클래스 → 세분화된 책임을 정의한 인터페이스(SqlReader, SqlService, SqlRegistry)를 구현
    * XmlSqlService클래스 하나가 세 개의 인터페이스를 다 구현하게 해보기. 단 책임이 다른 코드는 다른 클래스의 코드이지만 직접 접근하지 않고 인터페이스를 통해 간접적으로 사용하게 변경한다.
* 자기참조 빈은 확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할 때 처음 시도할 수 있는 방법


## 7.4 인터페이스 상속을 통한 안전한 기능확장
권장되진 않지만, 서버 운영중에 SQL을 변경해야할 수도 있다. 애플리케이션을 재시작하지 않고 특정 SQL내용만 변경하고 싶다면 어떻게 해야할까?

### DI
* DI는 런타임 시에 의존관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮춘다.
* DI를 적용할 때는 최대한 두 개의 객체가 인터페이스를 통해 느슨하게 연결되어야 한다.
    1. 다형성을 얻을 수 있기 때문이다.
    2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 해줄 수 있기 때문이다.
* 이렇게 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 분리하는 원칙을 인터페이스 분리 원칙 이라고 부른다.

### 인터페이스 
때로는 인터페이스를 여러 개 만드는 대신 기존 인터페이스를 상속을 통해 확장하는 방법도 사용된다.

![image](https://github.com/kmularise/TIL/assets/106499310/af947f7a-2f4f-4808-83db-851046bd99b3)

## 7.5 DI를 이용해 다양한 구현 방법 적용하기
* 운영 중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업은 동시성 문제를 고려해야 한다.
1. HashMap 대신 동기화된 해시 데이터 조작에 최적화되게 만들어진 ConcurrentHashMap을 사용해서 구현하기
2. 내장형DB를 사용해서 구현하기
3. 트랜잭션 적용

## 7.6 스프링 3.1의 DI
