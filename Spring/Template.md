# 템플릿

개방 폐쇄 원칙(OCP)를 보면, 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지려고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음을 알 수 있다.
각각 다른 목적과 다른 이유에 의해 다른 시 점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 바로 걔방 폐쇄 원칙이다.

* 템플릿 : 코드 중에서 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법

리소스 반환


예외 처리
try catch finally의 문제점
변하는 것과 변하지 않는 것

변하지 않지만 중복되는 코드와 로직에 따라 확장되고 변하는 코드를 분리해내야 한다.

## 분리와 재사용을 위한 디자인 패턴 적용
### 메소드 추출
```
pg 217 코드
```
변하는 부분을 메소드로 추출하고 변하지 않는 부분에서 호출
메소드 추출 리팩토링은 분리시킨 메소드를 재사용할 수 있어야 하는데, 이 경우, 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드가 새롭게 확장돼야 하는 부분이라 별 효용이 없다.

### 템플릿 메소드 패턴
```
pg 218 코드
```
* 변하지 않는 부분은 상위클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 하위 클래스에서 오버라이딩
* 개방 폐쇄 원칙(OCP)를 지키는 구조를 만들어낼 수는 있으나, DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
* 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다. 이미 클래스 레벨에서 컴파일 시점에 관계가 결정되어 있다. 관계에 대한 유연성이 떨어져 버린다.

### 전략 패턴
```
pg 220-221 코드
```
전략 패턴 : 개방 폐쇄 원칙을 잘 지키는 구조,
* 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어나다.
    * 오브젝트를 아예 둘로 분리하고 클래스 레벨에서 인터페이스를 통해서만 의존하도록 만듬
* 그러나 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP 폐쇄 원칙) 전략을 바꿔 쓸 수 있다(OCP 개방 원칙)는 것이다. 하지만 이렇게 컨텍스트 안에서 구체적인 전략 클래스를 사용하도록 고정되어 있는 것은 적절치 않다. 구현클래스를 직접 알고 있다는 건 전략 패턴에도 OCP는 들어맞지 않는다.

### 