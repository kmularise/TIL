# MySQL 락
## 스토리지 엔진 레벨 
* 테이블의 데이터를 다루기 위한 락
### 공유락(Shared Lock) / 배타 락(Exclusive Lock)
* 공유 락(S-Lock)과 배타 락(X-Lock)이라는 레코드 레벨의 락
* 공유 락
    * 해당 락을 보유한 트랜잭션이 해당 레코드를 읽을 수 있도록 한다.
    * 트랙잭션이 S-Lock 보유 시 다른 트랜잭션은 S-Lock을 보유할 수 있다.
* 배타 락 : 해당 잠금을 보유한 트랜잭션이 행을 업데이트하거나 삭제할 수 있도록 만든다.
    * 트랜잭션이 X-Lock 보유 시 다른 트랜잭션은 어떤 락이든 허용되지 않고 계속 대기해야 한다.

```SQL
# 쓰기 잠금(베타락)
SELECT * FROM member WHERE last_name LIKE "E%" FOR UPDATE;
# 읽기 잠금(공유락)
SELECT * FROM member WHERE last_name LIKE "E%" LOCK IN SHARE MODE;
```

### 레코드 락(Record Lock)
* 일반적으로는 테이블 레코드 자체를 잠그는 락
* MySQL에서의 레코드 락은 테이블의 레코드가 아닌 인덱스의 레코드를 잠근다.
    * MySQL에서 인덱스와 테이블은 별도의 자료구조로 관리되는데, MySQL에서는 아래의 그림과 같이 인덱스에 락이 걸린다. 참고로 여기서 락이 걸리는 인덱스는 클러스터 인덱스(PK) 및 논클러스터 인덱스(세컨더리 인덱스) 모두를 포함한다.
    * PK가 없는 테이블이라면 내부적으로 자동 생성된 PK를 이용해 설정한다.

### 갭 락(Gap Lock)
* 갭 락은 아직 존재하지는 않지만 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금
* 갭 락은 레코드가 아닌 레코드와 레코드 사이의 간격을 잠금으로써 레코드의 생성, 수정 및 삭제를 제어
* 갭 락은 인덱스 범위 조건 중에서 실제 레코드를 제외하고, 데이터가 추가될 수 있는 범위에 걸리게 된다.

### 넥스트 키 락(Next Key Lock)
* 레코드 락과 갭 락을 합친 잠금
* 갭 락은 단독으로 사용되기 보다는 넥스트 키 락의 일부로 함께 사용된다.
* 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 리플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 주목적

### 자동 증가 락(Auto Increment Lock)
* MySQL에서는 auto_increment라는 컬럼을 통해서 자동으로 증가하는 값을 관리
* auto_increment가 사용된 테이블에 여러 개의 레코드가 삽입되는 경우, auto_increment 역시 일관성있게 증가해야 한다.
    * innoDB에서는 자동 증가 락을 통해 이를 관리한다. 
* 테이블 레벨 락
* MySQL 8.0 : innodb_autonic_lock_mode=2
    * innodb_autonic_lock_mode가 2로 설정되면 InnoDB 스토리지 엔진은 절대 자동 증가 락을 걸지 않고 항상 경량화된 래치(뮤텍스)를 사용한다.
    * 하나의 INSERT 문장으로 INSERT되는 레코드라 하더라도 연속된 자동 증가 값을 보장하지는 않는다.
    * 이 설정에서 작동하는 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장하므로 복제를 사용하는 경우에는 마스터와 슬레이브의 자동 증가 값이 달라질 가능성이 있으므로 주의해야 한다.

## MySQL 엔진 레벨
### 글로벌 락
* MySQL에서 제공하는 락 중에서 가장 범위가 큰 락
* 하나의 세션에서 글로벌 락을 획득하면 다른 세션에서 select를 제외한 대부분의 DDL / DML 문장 실행 시, 글로벌 락이 해제될 때까지 계속 대기 상태로 남게 된다.
* 만약, 글로벌 락이 실행되기 전에 쓰기 락이 걸린 SQL이 실행됐다면, 기존의 쓰기 락이 완전히 해제된 이후에 글로벌 락이 걸리게 된다.

### 백업 락
* MySQL 8.0부터
* 백업 락의 경우 특정 세션에서 획득하면 모든 세션에서 아래와 같은 정보를 변경할 수 없다.
> - 데이터베이스나 테이블 등, 모든 객체의 생성 및 변경, 삭제
> - REPAIR TABLE / OPTIMIZE TABLE
> - 사용자 관리 및 비밀번호 변경
* 일반적인 테이블의 데이터 변경은 허용
* 백업 작업을 위해 도입됨

### 테이블 락
* 테이블 단위로 설정하는 잠금
* 명시적 (explicit) / 암시적 (implicit) 락
    * 명시적 락 : 쿼리를 통해 직접 선언
    * 묵시적 락 : 테이블을 변경하는 쿼리를 실행했을 때 MySQL 서버가 해당 테이블에 락을 설정하고 데이터를 변경한 다음, 바로 락을 해제하는 형태
* READ / WRITE 옵션
> READ
> - 테이블에 대한 읽기 락 획득
> - 다른 세션이 동시에 같은 테이블에 대한 읽기 락 획득 가능
> - 테이블에 대한 내용은 읽을 수 있지만, 수정은 불가능 
> - 동시에 다른 세션이 해당 테이블에 대해서 쓰기 락 획득 불가능
> 
> WRITE
> - 테이블에 대한 쓰기 락 획득 
> - 다른 세션이 동시에 같은 테이블에 대한 읽기 락, 쓰기 락 획득 불가능
> - 쓰기 락을 획득한 세션은 테이블의 내용을 읽고 수정할 수 있음

### 네임드 락
* 테이블, 레코드가 아닌 임의의 문자열에 대해 잠금을 획득할 수 있다.
* 1대의 DB 서버에 여러 대의 웹 서버가 접속하였을 때 특정 정보를 동기화해야 하는 상황에서 네임드락을 사용할 수 있다.
* 복잡한 조건으로 레코드를 한꺼번에 많이 변경할 때 사용
* MySQL 8.0부터는 네임드 락을 중첩하여 사용하는 것을 가능하도록 만들었다.# hello라는 문자열에 대해서 잠금 획득
```SQL
# hello라는 문자열에 대해서 잠금 획득
# 이미 사용 중이라면 2초 대기 후 해제
SELECT GET LOCK('hello', 2);

# 잠금이 설정되어 있는지 확인
SELECT IS_FREE_LOCK('hello');

# hello라는 문자열에 대해 획득했던 잠금 해제
SELECT RELEASE_LOCK('hello');
```
### 메타데이터 락
* 테이블이나 뷰의 이름이나 구조를 변경하는 경우, 메타데이터 락을 획득
* 명시적으로 획득하거나 해제는 할 수 없다.
* RENAME 등의 쿼리를 실행할 때 자동으로 획득하는 잠금
```SQL
# 이러면 tb_1, tb_2 모두에 대해서 잠금을 설정한다
RENAME TABLE tb_1 TO tb_2;
```

<!-- https://mangkyu.tistory.com/53 -->
<!-- https://mangkyu.tistory.com/298 -->