# equals와 hashCode

## equals() 규칙
- 어떠한 객체 x는, x.equals(x)가 항상 참이다
- 어떠한 객체 x,y는 y.equals(x)가 참이면 x.equals(y)가 참이다
- 어떠한 객체 x,y,z는 만약 x.equals(y)가 참이고 y.equals(z)가 참이면, x.equals(z)는 참이다
- equals() 메서드 구현에서 사용되는 객체 속성이 수정되지 않는 한 x.equals(y)를 여러 번 호출하면 동일한 결과를 반환해야 한다.
- 객체 클래스 equals() 메소드 구현은 두 참조가 동일한 객체를 가리키는 경우에만 참이다.

## hashCode() 규칙
- 만약 equals() 메소드에서 사용되는 개체 속성이 변하지 않는다면, hashCode()를 여러 번 호출해도 동일한 정수 값을 반환해야 한다.
- 개체 해시 코드 값은 같은 어플리케이션의 여러 번 실행에 변경될 수 있다.
- 2개의 개체가 equals() 메소드 비교에서 똑같다면, 해시 코드도 같아야 한다.
- 2개의 개체가 equals() 메소드 비교에서 다르다면, 해쉬 코드가 같은 수도 있고 다를 수도 있다.

## equals와 hashCode
* hashCode()는 해시 알고리즘에 의해 생성된 int형 값을 반환한다.
* equals() 메소드에 따라 동일한 객체로 판명된 객체들은 반드시 동일한 hashCode를 가져야 한다. 서로 다른 객체가 반드시 다른 hashCode를 반환할 필요는 없다.
* 하지만 서로 다른 객체가 고유한 int형 값을 생성하면 해시테이블의 성능이 향상된다.

## equals()와 hashCode()를 함께 재정의(오버라이드) 해야하는 이유
해시 기반의 컬렉션을 사용하는 HashMap, HashSet, Hashtable 등은 모두 해쉬 기반으로 hashCode()와 equals()을 동시에 사용하는데, 만약 하나만 재정의 하는 경우 기존 규칙을 위반하여 원하는 결과가 나오지 않기 때문이다. equals만 재정의하고 hashcode를 재정의하지 않는다면 hashCode 규칙 "2개의 개체가 equals() 메소드 비교에서 똑같다면, 해시 코드도 같아야 한다."을 어기거나 해시충돌이 발생해 해시테이블의 성능을 저하시킬 수 있다.

_____________________________
## 해시 충돌
해시 함수가 서로 다른 두개의 입력값에 대해 같은 출력값을 내는 상황
__________________________________
![Alt text](image-25.png)

## 해시 충돌 해결: 체이닝(chaining)
* Java HashMap에서 해시 충돌을 해결하는 방법
* 같은 주소로 해싱되는 원소를 모두 하나의 연결리스트에 매달아서 관리한다.
* 해시충돌 시 해당 버킷값을 첫 부분으로 하는 연결리스트로 해결한다
* 원소를 검색할 때는 해당 연결 리스트의 원소들을 차례로 지나가면서 탐색한다.

## 해시 충돌 해결: 개방 주소 방법(open addressing)
* 해시 충돌이 발생하면 다른 버킷에 해당 데이터를 삽입하는 방식
* 체이닝과 달리 어떻게든 주어진 테이블 공간에서 해결한다.
* 따라서 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다.
* 선형 조사(linear probing), 이차원 조사(quadratic probing), 더블 해싱(double hashing)

### 선형 조사(linear probing)
* 가장 간단한 충돌 해결 방법
* 충돌이 일어난 자리에서 i에 관한 일차 함수의 보폭으로 점프한다.
* h_i(x)는 h(x)에서 i만큼 떨어진 자리이다.
* 테이블의 경계를 넘어갈 경우에는 맨 앞으로 돌아간다.

### 이차원 조사(quadratic probing)
* 바로 뒷자리를 보는 대신 보폭을 이차 함수로 넓혀가면서 본다.
* 예를 들어, i번재 해시 함수를 h(x)에서 i^2 만큼 떨어진 자리로 삼는다.
* 즉, h(x), h(x) + 1, h(x) + 4, h(x) + 9, h(x) + 16, ...
* 특정 영역에 원소가 몰려도 그 영역을 빨리 벗어날 수 있다.

### 더블 해싱(double 해싱)
* 두개의 함수를 사용한다.
* 하나의 함수는 최초의 해시값을 얻을 때, 다른 하나의 함수는 해시 충돌이 일어났을 때 이동할 폭을 얻을 때 사용한다.
* 두 원소의 첫번째 해시값이 같더라도 두번째 해시값까지 같을 확률은 매우 작으므로 서로 다른 보폭으로 점프를 하게 된다.
_________________________________________________
## 해시함수의 특징
* 같은 입력값에 대해서 같은 출력값이 보장된다.
* 서로 다른 입력값으로부터 동일한 출력값이 나올 가능성이 희박하므로 입력값에 대한 무결성이 보장된다.
* 일방향성을 갖는다. 해시코드에서 원래 값을 찾는 것은 불가능하다.
_______________________
## Secure Hash Algorithm(SHA)
* NSA(미국 국가안보국)에 의해 1933년 처음 개발된 해시 알고리즘
* 현재 주로 사용되는 것은 SHA-2 함수군으로, 다이제스트의 길이에 따라 SHA-256, SHA-512 등으로 나뉜다.
* SHA-0, SHA-1까지는 해시 충돌성이 존재하지만, SHA-256, SHA-512는 해시 충돌성이 사실상 0에 수렴한다.
* 256의 의미: 해싱을 하면 2^256개의 해시값 중 하나가 나타난다.
__________________________
## 해시의 응용
* 무결성 검사 - 파일 변조 감지
* 클라우드 스토리지에서 동일한 파일 식별 및 수정된 파일 검출
* 데이터베이스에 비밀번호를 저장할 때 사용
* 블록체인
* Git

## 참고자료
* https://www.baeldung.com/java-hashcode
* https://www.youtube.com/watch?v=Rpbj6jMYKag
* https://odol87.tistory.com/4
