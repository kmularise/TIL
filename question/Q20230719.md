# 목차
* 1순위
1. stream 
2. Optional
3. interface의 디폴트메소드
4. lambda, functional interface
5. java.time
6. 부동 소수점
7. 조합

* 2순위
1. 무중단 배포란 무엇이고 종류
2. 좋은 해시함수란?
___________
# 자바 기본
[Java 8 변화 참고](../Java/Java8Change.md)
## stream [Java 7 변화 참고](../Java/Java7Change.md), [stream 참고](../Java/stream.md)
* stream 주요 장점
    * 병렬 처리 
        * Fork/Join 이용 : 작업을 할 때 여러 개로 나누어 연산한 후 결과를 모은다.
    * lazy evaluation
        * 연산이 실제로 필요할 때만 연산을 시작하는 것

* parallel stream 사용 시 (비동기 프로그래밍) 고려해야할 것
    * 쓰레드 작업 분할 비용과 쓰레드 작업 병합 비용
        * 이러한 비용이 크다면, 오히려 병렬처리가 비효율적일 수 있다.
    * 병렬 처리로 인한 캐시 미스(Cache Miss) 증가
        * 병렬 처리로 캐시 미스가 증가하게 된다면, 오히려 처리 속도가 늦어지게 된다.
    * 병렬 처리 시 공유변수 여러번 사용
        * 여러 쓰레드들이 공유 변수를 여러번 사용함에 따라 의도했던 결과와는 다른 결과가 나올 수 있다.

## Optional
* 객체를 편리하게 처리하기 위해 만든 클래스
* null 처리를 간편하게 하기 위해 만들어짐

## interface의 디폴트메소드
* 인터페이스에서 메소드를 구현할 수 있다.
* 만든 이유 : 하위 호환성 때문
## lambda, functional interface 람다표현식과 함수형 인터페이스(기능적 인터페이스)
* 익명 클래스를 사용하면 가독성이 떨어지고 불편하다는 단점이 있다.
* 이를 보완하기 위해 람다 표현식이 만들어짐
* 람다 표현식은 인터페이스에 메소드가 하나인 것들만 적용 가능하다.
* 함수형 인터페이스 : 하나의 메소드만 선언
* 함수형 인터페이스에 두 개 이상의 메소드 선언을 방지하기 위해 @FunctionalInterface 사용

## java.time 날짜 관련 클래스
* 불변 객체이고 쓰레드에 안전하다.


## 부동 소수점
* BigDecimal
    * 소수형 데이터를 저장할 수 있는 기본형 데이터 중 가장 크기가 큰 타입인 double은 소수점의 정밀도에 한계가 있어 값이 유실될 수 있다.
    * 이는 double 타입이 내부적으로 수를 저장할 때 이진수의 근사치를 저장하기 때문이다.
        * ex\) 0.6의 경우 0.10011001.. 이런식으로 1001 무한히 반복된다. 근사치이기 때문에 이러한 무한 자릿수를 반영할 수는 없는 것이다.
    * BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 연산에 대해 정밀도를 보장한다.
    ```java
    public static void main(String[] args) {

    double valueA = 12.34;
    double valueB = 34.56;
    double result = valueA + valueB;
    System.out.println(result); // 결과값 : 46.900000000000006
  }
    ```
* 부동소수점을 사용하는 이유
    - 고정소수점에 비해 표현 가능한 범위가 넓어져 주어진 자료형 크기를 효율적으로 사용할 수 있다.

![Alt text](image.png)
```참고
- 고정 소수점 방식 : 정수부와 소수부를 고정으로 나누고 지정하여 처리하는 방식. 소수부 자릿수가 미리 정해지기에 고정된 자릿수의 소수를 표현하기 직관적이다.
- 부동 소수점 방식 : 가수부와 지수부를 나눈다. 표현할 수 있는 값의 범위를 최대한 넓혀 오차를 줄일 수 있다.
```

* 부동소수점의 장단점
    * 장점
        - 고정소수점에 비해 표현할 수 있는 수의 번위가 넓다.
    * 단점
        - 주어진 최대 지수부 자릿수와 가수부 자릿수를 넘어서면 부정확한 계산을 하게 된다.
## 조합 (composition, 조립)
* [컴포지션(composition) 참고](../Java/effective_Java/item18_composition.md)
* 상속의 단점
    * 캡슐화를 위반한다.
        * 상위 클래스의 내부 구현이 바뀌면 하위 클래스의 내부 구현도 바뀌어야 한다.
    * 유연하고 확장성 있는 구조를 설계하기 어렵다.
        * 상위 클래스에 기능이 추가된다면 하위클래스에서 그 기능을 다시 오버라이딩 해야 한다. (유연하지 않음)
        * 하위 클래스에서 새로운 메소드를 따로 정의하는 것도 문제가 된다. 나중에 상위클래스에서 새로운 메소드와 같은 메소드를 정의하고 접근제어자의 접근 권한이 확장했을 때 오류가 나기 때문이다. (확장성이 떨어짐)
* 조합
    * 기존 클래스가 새로운 클래스의 구성요소로 쓰이는 설계 : 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조
    * 전달(forwarding) : private 필드(인스턴스 변수, 클래스 변수)를 참조하는 새 클래스의 인스턴스 메소드들은 기존 클래스에 대응하는 메소드를 호출해 그 결과를 반환한다.
* 조합의 장점
    * 기존 클래스의 구현이 바뀌거나, 새로운 메소드가 생기더라도 아무런 영향을 받지 않는다. 즉, 캡슐화가 보장되고 확장성 있는 구조 설계가 가능하다.

## 무중단 배포
* [참고](../Infrastructure/CI_CD.md)
* 무중단 배포란?
    * 서비스를 중단하지 않고 배포하는 것
    * 서비스가 중단되는 기간? 이전 버전 서비스를 종료하고 새로운 버전 서비스를 시작할 때까지
    * 무중단 배포를 위해 필요한 조건 :
        1. 서버 두대 이상
        2. 리버스 프록시 : 클라이언트와 서버 사이를 중계, 서버를 숨겨주는 역할, 클라이언트가 서버 IP를 몰라도 됨
        3. 로드 밸런싱 : 하나의 서버에서 받아야할 요청을 여러 서버로 분산
* 무중단 배포 종류
    * Rolling 배포
        * 무중단 배포의 가장 기본적인 방식
        * 서버를 차례대로 업데이트 시키는 방식
        * 장점
            * 인스턴스를 추가하지 않아도 되서 관리가 간편
        * 단점
            * 사용중인 인스턴스에 트래픽이 몰릴 수 있음
            * 구버전과 신버전의 공존으로 인한 호환성 문제
    * Canary 배포
        * 신버전을 소수의 사용자들에게만 배포
        * 문제가 없는 것이 확인되면 점진적으로 다른 서버에 신버전 배포

        * 장점
            * 문제 상황을 빠르게 감지 가능
            * A/B 테스트로 활용 가능
                * 분할 테스트 또는 버킷 테스트라고도 하는 A/B 테스트는 두 가지 콘텐츠를 비교하여 방문자/뷰어가 더 높은 관심을 보이는 버전을 확인
        * 단점
            * 모니터링 관리 비용
            * 구버전과 신버전의 공존으로 인한 호환성 문제
    * Blue / Green 배포
        * Blue를 구버전, Green을 신버전으로 지칭
        * 구버전과 동일하게 신버전의 인스턴스를 구성
        * 신버전 배포 시 로드 밸런서를 통해 신버전으로만 트래픽을 전환

        * 장점
            * 배포하는 속도가 빠르다.
            * 신속하게 롤백 가능
            * 남아 있는 기존 버전의 환경을 다음 배포에 재사용
        * 단점
            * 시스템 자원이 2배로 필요


## 좋은 해시함수란?
* [참고](../Java/hash.md)
* 키를 고르게 분포시킬 수 있어야 한다.
* 충돌 발생 빈도가 적어야 한다.
* 연산이 빨라야 한다.
## 참고자료
https://stackoverflow.com/questions/322749/retain-precision-with-double-in-java/322875#322875

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%9B%90%EB%A6%AC-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#:~:text=%EA%B0%99%EC%9D%80%20%EC%8B%A4%EC%88%98%EB%9D%BC%EA%B3%A0%20%ED%95%B4%EB%8F%84%20%EC%A0%95%EC%88%98%EB%B6%80,%EC%86%8C%EC%88%98%EC%A0%90%20%EB%B0%A9%EC%8B%9D%EC%9D%84%20%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4.

https://yoongrammer.tistory.com/82#:~:text=%EC%A2%8B%EC%9D%80%20%ED%95%B4%EC%8B%9C%20%ED%95%A8%EC%88%98%EC%9D%98%20%EC%A1%B0%EA%B1%B4,%EB%B9%A0%EB%A5%B8%20%EC%97%B0%EC%82%B0.

https://velog.io/@znftm97/%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%99%98%EA%B2%BD-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0