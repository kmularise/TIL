# SOLID
## SOLID 원칙에 대해 설명해주세요.
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
    * 한 클래스는 하나의 책임만 가져야 합니다. 한 클래스가 변경되어야 하는 이유는 단 하나여야 합니다.
2. OCP(Open Closed Principle) : 개방 폐쇄 원칙
    * 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 합니다. 기존의 코드를 변경하지 않고도 확장할 수 있어야 합니다. 이를 통해 기능 추가나 변경이 기존 시스템에 미치는 영향을 최소화할 수 있습니다.
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
    * 하위클래스는 언제든지 상위클래스로 교체될 수 있어야 합니다.
4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
    * 클라이언트는 사용하지 않는 인터페이스에 의존해서는 안된다. 하나의 일반적인 인터페이스보다는, 필요한 클라이언트 별로 구체적인 인터페이스를 여러 개 만들어야 합니다.
5. DIP(Dependency Inversion Principle): 의존 역전 원칙
    * 상위 모듈은 하위 모듈에 의존해서는 안됩니다. 추상화는 세부사항에 의존해서는 안됩니다. 의존 관계를 맺을 때 변화하기 쉬운 것에 의존하기보다는, 변화하지 않는 것에 의존하라는 원칙입니다.

## SOLID 원칙 중, 사용해본 원칙은?
SOLID 원칙 중에서 SRP와 OCP를 주로 사용했습니다. 
SRP를 사용해서 각 클래스에 적절한 역할을 부여해서 클래스가 하나의 역할을 맡도록 했습니다.
OCP를 사용해서 각 클래스의 구현이 바뀌게 될 때, 다른 클래스에 영향을 미치지 않게끔 했습니다. 

## OCP - 확장에는 열려있고, 수정에는 닫혀있다는 것은?
새로운 기능이나 요구 사항이 생겼을 때, 기존의 코드를 변경하지 않고도 확장할 수 있어야 합니다.

## 추상화에 대해 설명해주세요
추상화란 불필요한 세부사항은 생략하고 필요한 기능만 사용자에게 제공하는 것입니다.
## 추상화 사용 이유에 대해 설명해주세요
1. 코드의 복잡성을 줄입니다.
2. 코드의 중복을 방지하고 재사용성을 증가시킵니다.
3. 내부 시스템의 변경이 최종사용자에게 영향을 주지 않아 OCP원칙을 지킬 수 있고 기능 개선이 쉬워집니다.
4. 모듈화를 할 수 있고 관심사를 분리하여 코드의 유지보수가 용이해집니다.
5. 사용자에게 구현 세부사항의 복잡성을 숨겨 사용자가 이해하고 사용하기 쉬워집니다.

* [geeks for geeks](https://www.geeksforgeeks.org/abstraction-in-java-2/)

# 상속
## 정사각형이 직사각형에 속한다."를 상속으로 어떻게 나타낼까요?
상속으로 나타내기에는 어려운 점들이 있습니다. 직사각형이 할 수 있는 것들 중에 정사각형이 하기 어려운 동작이 있기 때문입니다. 정사각형을 직사각형처럼 가로만 늘리거나 세로만 늘리기 어렵습니다. 
## 상속을 사용했을 때, 고려해야할 것들?
상속을 사용했을 때, 상위클래스와 하위클래스가 is-a 관계인지 고려해야 합니다. 
## 상속의 단점과 대안에 대해 설명해주세요.
* 상속의 단점
    1. 강한 결합 : 부모 클래스와 자식 클래스 간에 강한 관계가 형성됩니다. 부모 클래스에 변경이 일어나면 자식 클래스에 영향을 줄 수 있습니다.
    2. 추상화 위배 : 특정 기능만 필요한 경우에도 부모 클래스의 불필요한 기능까지 상속받게 됩니다.
* 대안 
    * 컴포지션(조합) : 필드에 객체들을 가지고 있게끔 합니다. 컴포지션은 유연한 관계를 형성하며 필요한 부분만 조합하여 사용합니다.

## LSP - 위 내용과 객체지향을 엮어서 설명해줄 수 있는지?
직사각형처럼 너비와 높이를 독립적으로 변경하는 동작은 정사각형의 정의를 위반할 수 있습니다. 이는 정사각형을 직사각형의 하위 클래스로 만드는 것은 LSP를 위반할 수 있습니다. 정사각형(하위클래스)가 직사각형(상위 클래스)로 완벽하게 대체될 수 없습니다.
# 자료구조
## HashMap과 Concurrent HashMap
HashMap과 Concurrent HashMap은 Map 자료구조이고 동시성 처리에 차이를 보입니다.
## HashMap과 Concurrent HashMap의 차이
HashMap은 동기화되지 않습니다. Concurrent HashMap은 버킷 별로 부분적으로 락을 거는 방식으로 스레드 동기화를 하고 있습니다.
## 성능 비교를 해본 적이 있는지?
단일 스레드 환경에서는 동기화로 인한 오버헤드가 없어서 HashMap이 빠릅니다. 멀티스레드 환경에서는 ConcurrentHashMap이 버킷별로 부분적으로 잠금을 하고 있기 때문에 스레드 동기화로 인한 성능 저하가 크게 나타나지 않습니다. 오히려 HashMap을 스레드 동기화를 외부에서 처리할려고 하면 성능저하가 크게 나타날 수 있습니다. 
## 불변 객체의 단점은 뭔가요
객체의 값이 변할때마다 새로운 객체를 생성하고 할당해야 합니다. 같은 값을 가지는 객체가 애플리케이션 안에 중복되어 존재할 수도 있습니다. 
## 에러와 예외에 대해 설명 해주세요
* 에러 : Throwable의 하위 클래스로 애플리케이션이 처리하지 않는 심각한 문제상황을 나타냅니다. 에러와 하위 클래스는 컴파일 타임에 확인하지 않는 unchecked exception으로 간주된다.
* 예외 : Throwable의 하위 클래스로 애플리케이션이 처리할 수 있는 상황을 나타냅니다. RuntimeException과 그 하위클래스들은 unchecked exception이고, 그 외는 checked exception입니다. 
* [java error](https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html)
* [java exception](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Exception.html)

## Set, List의 자료구조 차이에 대해 설명해주세요.
Set은 순서가 없고 중복이 존재하지 않는 자료구조입니다. 반면 List는 순서가 있고 중복이 허용되는 자료구조 입니다.
## Set은 순서를 보장할까요?
Set은 순서를 보장하지 않습니다.
## ArrayList의 가장 큰 특징은 무엇이라고 생각하시나요?
ArrayList는 가장 큰 특징은 가변배열을 구현한 것입니다. 따라서 ArrayList에 요소가 추가됨에 따라 capacity는 자동적으로 증가하고, 인덱스가 있어 각 요소에 빠르게 접근할 수 있습니다.
# 라이브러리와 프레임워크의 차이
* 라이브러리
    * 정의 : 특정 기능을 수행하기 위한 함수나 객체의 집합
    * 제어권 : 개발자에게 제어권이 있습니다.개발자가 라이브러리를 선택적으로 호출하여 사용합니다.
* 프레임워크
    * 정의 : 애플리케이션의 기본 구조를 제공하는 코드의 집합으로 일련의 규칙이나 구조를 따라야 합니다.
    * 제어권 : 프레임워크에게 제어권이 있습니다. 개발자는 프레임워크의 규칙에 맞춰서 코드를 작성하고, 프레임워크가 적절한 시점에 개발자의 코드를 호출합니다. 이를 제어의 역전이라 합니다. 
# String, StringBuffer, StringBuilder의 차이점이 무엇인가요?
* String
    * 불변클래스
* StringBuffer
    * 가변클래스
    * 스레드 안전
* StringBuilder
    * 가변 클래스
    * 스레드 안전하지 않숩나더,
# 서버에 세션을 저장할 때, HashMap vs Concurrent HashMap
Concurrent HashMap을 이용할 것 같습니다. 
그 이유는 새로운 세션 아이디가 추가될 때, 해시 충돌이 난다면 같은 버킷을 사용하기에 스레드 동기화가 이루어져야 새로운 세션 아이디가 유실되지 않습니다. Concurrent HashMap은 또한 읽기 작업 시에는 volatile 변수를 사용하여 메인메모리와 동기화를 지원해서 데이터의 일관성을 유지히고 락을 걸지 않고 읽기 작업을 수횅할 수 있습니다. 쓰기 작업시에도 해시 충돌이 일어나지 않는 경우 CAS알고리즘으로 락을 걸지 않고 해시 충돌이 일어나는 경우에만 잠금을 걸기 때문에 성능 저하가 크게 되지 않습니다.

실제 HttpSession의 구현체를 살펴보면 Concurrent HashMap을 사용하고 있습니다.

# final에 대해 설명해주세요
final은 클래스, 변수, 메소드에 사용할 수 있습니다.
final을 클래스에 사용하게 되면, 상속될 수 없습니다. 이를 통해 하위클래스가 예상된 동작을 변경하는 것을 방지합니다.
final을 메소드에 사용하게 되면 오버라이딩을 할 수 없습니다. 이는 메소드의 구현이 변경되는 것을 방지하기 위해 사용됩니다. 특정 기능이 모든 하위 클래스에서 일관되게 유지될 수 있습니다.
final을 변수에 사용하게 되면, 값이 한번 초기화되면 수정될 수 없습니다. 객체 참조의 경우에는 객체의 내부 상태는 변경될 수 있습니다.