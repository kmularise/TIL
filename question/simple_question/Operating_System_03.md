# 페이징
## 페이징과 세그멘테이션이란?
* 페이징 : 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
    * 내부단편화 O, 외부단편화 X
* 세그멘테이션 : 프로세스를 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식
    * 내부단편화 X, 외부단편화 O
>프레임: 물리 메모리를 일정한 크기로 나눈 블록
><br>페이지 : 가상 메모리를 일정한 크기로 나눈 블록
><br>세그먼트 : 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미
[참고]
* [https://steady-coding.tistory.com/524](https://steady-coding.tistory.com/524)

## 페이징이 메모리 효율적인 이유
메모리와 프로세스를 물리적으로 같은 크기로 분할하므로 외부 단편화 문제를 해결해서 메모리 효율적입니다.
## 사용하지 않는 영역을 메모리 공간에 올라가는 이유
1. 운영체제나 애플리케이션이 예상되는 메모리 요구에 대응하여 미리 메모리를 할당할 수 있습니다. 이 때 실제로 사용하지 않는 영역이 메모리에 할당할 수 있습니다.

2. 페이징 기법 사용 시 프로세스가 페이지 전체를 다 사용하지 않을 경우, 남은 부분은 내부 단편화로 인해 사용되지 않습니다. 
# 페이지 교체 알고리즘
## 페이지 교체 알고리즘이란?
페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시 교체할 페이지 프레임을 결정하는 방법입니다.

## LRU 알고리즘이란?
가장 오래 전에 참조된 페이지를 지우는 알고리즘입니다.

>OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
><br>FIFO - First In First Out
><br>LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
><br>LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체

## FIFO의 단점은?

FIFO는 먼저 들어온 페이지를 먼저 교체하는 알고리즘으로 프레임 수를 증가시켜도 오히려 페이지 폴트 비율이 증가할 수 있다는 단점이 있습니다.

![image](https://github.com/kmularise/TIL/assets/106499310/2d8bddda-b83a-4faa-b033-b0c2e73bbee0)

# 동기와 비동기
## 동기와 비동기 차이

전체적인 작업에 대한 순차적인 흐름 유무

* 동기 : 요청한 작업에 대해 순서가 보장되는 것
* 비동기 : 요청한 작업에 대해 순서가 보장되지 않는 것, 특정 작업의 실행이 완료되지 않아도 다음 작업을 완료할 수 있습니다.
## 비동기와 병렬의 차이
* 비동기 : 요청한 작업에 대해 순서가 보장되지 않는 것
* 병렬 : 여러 작업을 멀티 코어에서 병렬적으로 실행, 물리적으로 동시에 실행되는 것

[참고]
* [동시성 프로그래밍, 병렬성 프로그래밍과 비동기 프로그래밍](https://m.boostcourse.org/mo326/lecture/16866#:~:text=%EB%8F%99%EC%8B%9C%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC%20%EB%B3%91%EB%A0%AC%EC%84%B1%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D,%EB%B9%84%EC%9C%A0%ED%95%B4%20%EB%B3%BC%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.&text=%EC%A6%89%2C%20%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%80%20%EC%8B%B1%EA%B8%80%EC%BD%94%EC%96%B4,%EC%BD%94%EC%96%B4%EC%97%90%EC%84%9C%EB%A7%8C%20%EA%B5%AC%ED%98%84%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4)

## 비동기를 핸드폰 알람과 엮어 이야기
알람은 비동기 처리를 통해 기능을 구현할 수 있습니다. 운영체제는 알람 이벤트가 발생하면 현재 진행중인 작업이 완료되지 않아도 알람 이벤트를 처리할 수 있습니다. 이를 통해 효율적으로 작업을 관리할 수 있습니다.

# 블로킹 I/O 와 논 블로킹 I/O
* 블로킹 I/O
    * I/O 작업이 진행되는 동안 유저 프로세스가 자신의 작업을 중단한 채, I/O가 끝날 때까지 대기하는 방식
    * Read()를 호출해 커널에 read I/O를 요청하면 read I/O가 끝날 때까지 애플리케이션이 block되어 다른 작업을 하지 못합니다.

![image](https://github.com/kmularise/TIL/assets/106499310/86dcd188-ba6b-40e5-8f01-b1e60469b4fe)
* 논 블로킹 I/O
    * I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식
    * 애플리케이션은 I/O 작업이 완료되기 전에 다른 작업을 수행할 수 있습니다. 
    * read I/O를 위한 시스템 콜을 호출하면, 커널의 I/O 작업 완료 여부와 무관하게 즉시 응답합니다.
    * 애플리케이션은 다른 작업들을 수행하다가 중간 중간 시스템 콜을 호출해서 I/O가 완료되었는지 커널에 확인하고, 완료되면 I/O 작업을 완료합니다.

> EWOULDBLOCK : 데이터가 없다는 메시지 

<img width="300" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/1d8027e2-7615-418d-80de-62445edba9a3">

## 논 블로킹 IO 감지 방법

read I/O를 위한 시스템 콜을 호출하면, 커널의 I/O 작업 완료 여부와 무관하게 즉시 응답합니다. 커널이 시스템 콜을 받자마자 CPU 제어권을 다시 애플리케이션에게 넘겨줍니다. 애플리케이션은 다른 작업들을 수행하다가 중간 중간 시스템 콜을 호출해서 I/O가 완료되었는지 커널에 확인하고, 완료되면 I/O 작업을 완료합니다.

## 논 블로킹 IO 주의할 점
* 에러 처리 
    * Non-blocking I/O 작업은 즉시 결과를 반환하지 않으므로, 에러를 적절히 처리하는 것이 중요합니다. 각 작업에 대한 에러 콜백을 제공하거나 catch 블록을 사용하여 에러를 적절히 처리해야 합니다. 
* 자원 관리
    * 반복적으로 시스템 호출이 발생하기에 자원 낭비가 발생할 수 있습니다. 이에 따라 자원 관리가 필요합니다.

## 비동기와 논 블로킹의 차이점

<img width="611" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/6135c133-a21a-43f3-8353-496390f7a608">

* 비동기 : 요청한 작업에 대해 순서가 보장되지 않는 것

<img width="502" alt="image" src="https://github.com/kmularise/TIL/assets/106499310/30db124f-8a10-42dd-93d0-ee68a1c926ff">

* 논블로킹 : 요청을 한 즉시 제어권을 호출자에게 반환하는 것. 어떤 작업이 실행되는 동안 그 작업의 완료를 기다리지 않고 다른 작업을 계속 수행할 수 있습니다.

[참고]
* [동기, 비동기, 블로킹, 논블로킹](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)