# 문법
## DELETE와 TRUNCATE 차이가 무엇일까요?
DELETE는 DML이고 원하는 데이터만 삭제할 수 있으며, 데이터를 모두 삭제해도 사용했던 저장공간은 반납되지 않습니다. 반면 TRUNCATE 데이터를 한꺼번에 삭제하며, 사용했던 저장공간을 반납하여 인덱스가 삭제됩니다.

* DELETE : 데이터는 지워지지만 테이블 용량은 줄어 들지 않습니다. 원하는 데이터만 지울 수 있습니다.  삭제 후 잘못 삭제한 것을 되돌릴 수 있다.
* TRUNCATE :  용량이 줄어 들고, 인덱스 등도 모두 삭제 된다. 테이블은 삭제하지는 않고, 데이터만 삭제한다. 한꺼번에 다 지워야 한다. 삭제 후 절대 되돌릴 수 없다.
* DROP 명령어는 데이블 전체를 삭제, 공간, 객체를 삭제한다. 삭제 후 절대 되돌릴 수 없다.

| | DROP | TRUNCATE | DELETE |
| ------ | ------ | ------ | ------ |
| SQL문 종류 | DDL | DDL | DML |
| 롤백 여부 | 롤백 불가능 | 롤백 불가능 | 커밋 이전 롤백 가능 |
| AUTO COMMIT 여부 | AUTO COMMIT | AUTO COMMIT | 사용자 COMMIT |
| 저장공간 | 반납 | 반납 | 유지 |
| 테이블 정의 | 삭제 | 존재 | 존재 |
| 작업속도 | 빠름 | 빠름 | 느림 |

## DROP과 TRUNCATE의 차이는 무엇일까요?
DROP은 테이블 정의 자체를 삭제하지만 TRUNCATE는 테이블 정의는 존재하며 테이블을 최초 생성된 초기 상태로 만듭니다.

## 외래키로 다른 테이블에 참조되고 있을 때 DROP, TRUNCATE, DELETE 동작
DROP, TRUNCATE, DELETE 모두 한 테이블에서 다른 테이블을 참조하고 있다면 삭제를 시도할 때 에러가 발생하면서 데이터가 삭제되지 않습니다. 외래키 제약 조건을 일시적으로 해제하고 테이블 삭제를 진행해야 합니다. 또는 CASCADE 옵션을 사용하여 연관된 모든 외래키를 자동으로 삭제할 수 있습니다.

```sql
SET foreign_key_checks = 0; // 체크 해제 
DELETE TABLE [테이블명] or TRUNCATE [테이블명] // 삭제 진행
SET foreign_key_checks = 1; //원 상태로 복귀 
```

## UNDO와 Rollback의 차이가 무엇일까요?
Undo는 주로 트랜잭션 중에 발생하는 개별 변경 사항을 취소하는 데 사용되며, undo log를 기반으로 합니다.
Rollback은 전체 트랜잭션을 취소하고, 시작 전 상태로 되돌리는 데 사용되며, 이 과정에서 undo log에 기록된 데이터를 활용합니다.

> undo log
> - 하나의 읽기-쓰기 트랜잭션과 연관된 undo log 레코드들의 모음
> - 언두 로그 레코드에는 트랜잭션이 클러스터 인덱스 레코드에 가한 최신 변경을 어떻게 되돌릴지에 대한 정보가 담겨 있습니다.

## DISTINCT와 Group by의 차이에 대해 설명해주세요
* DISTINCT
    * 중복되는 데이터 제거를 위해 사용됩니다.
    * 정렬을 하지 않고 Grouping 작업만 해서 결과를 출력해 GROUP BY에 비해 성능이 빠릅니다.
* GROUP BY
    * 데이터를 특정 기준에 따라 그룹화하고, 그룹 별로 집계 함수를 적용하여 그 결과를 정렬해 가져오는 경우에 사용합니다.
    * GROUP BY는 정렬된 결과를 보여줍니다.
> DISTINCT는 내부적으로 GROUP BY와 동일한 코드를 사용하지만, DISTINCT는 Grouping 작업만 하고, GROUP BY는 Grouping과 정렬 작업을 합니다. 

https://velog.io/@gillog/MySQL-DISTINCT-GROUP-BY
https://dev.mysql.com/doc/refman/8.0/en/distinct-optimization.html

## 중복을 제거할 때 DISTINCT와 Group by 중 어떤것을 사용하는 것이 성능이 좋을까요
DISTINCT는 Grouping 작업만 하고, GROUP BY는 GROUPING과 정렬작업을 하기 때문에 DISTINCT를 선택하는 것이 성능에 좋습니다.

# 동시성
## 데이터를 짧은 간격으로 동시 삽입할 경우, 어떻게 막으실건가요?
* 낙관적 락 또는 비관적 락 이용
* 트랜잭션 관리
    * 트랜잭션의 격리 수준을 설정하여 데이터 삽입 작업을 관리할 수 있습니다.
* 유니크 키 생성
    * 중복 삽입을 방지하기 위해 유니크 키를 생성합니다.

## MVCC(Multi Version Concurrency Control)란 무엇일까요?
* 변경된 레코드의 이전 버전에 대한 정보를 유지하여 동시성, 롤백과 같은 트랜잭션 기능을 지원합니다.
* 잠금을 사용하지 않는 일관된 읽기를 제공합니다.
* 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능입니다.

> 멀티 버전 : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리


## 동시성을 해결하는 방법에 대해 설명해주세요.
1. 비관적 락
    * 비관적 락은 충돌이 자주 발생할 것으로 가정하고, 데이터를 읽거나 수정하기 전에 해당 데이터에 락을 걸어 다른 트랜잭션이 접근하지 못하도록 합니다.
    * 락을 걸어 다른 트랜잭션의 접근을 차단합니다.
    * 일관성을 유지하는데는 효과적이지만, 락으로 인한 대기 시간이 있고, 데드락의 발생할 수 있습니다.
2. 낙관적 락
    * 낙관적 락은 충돌이 자주 발생하지 않을 것으로 가정하며, 데이터에 락을 걸지 않고 데이터를 읽거나 수정합니다.
    * 데이터를 업데이트 할 때, 데이터가 마지막으로 읽힌 이후 변경되지 않았는지 확인합니다. 이를 위해 버전(version)을 사용합니다.
    * 낙관적 락은 락으로 인한 대기시간이 없어 성능상 이점이 있지만, 충돌감지와 해결을 애플리케이션 레벨에서 관리해야 합니다.

## DB 데드락 발생조건이 무엇일까요?
모든 프로세스가 대기 상태이며 각 프로세스가 다른 프로세스가 가지고 있는 자원을 기다리고 있는 상태를 데드락이라고 합니다. 데이터베이스 관점에서는 트랜잭션 간 발생하는 것을 의미하며, 두 개의 트랜잭션이 각각의 트랜잭션이 가지고 있는 리소스의 락을 획득하려고 할 때 발생합니다.

데드락의 발생조건은 상호배제, 점유와 대기, 비선점, 순환대기 네가지 조건이 동시에 충족될 때 발생합니다.
1. 상호배제 (Mutual Exclusion) : 한번에 한개의 프로세스만 자원을 사용할 수 있어야 합니다.
2. 점유와 대기 (Hold and Wait) : 프로세스가 한개의 자원을 점유하고 있고 추가적으로 다른 프로세스의 자원을 점유하기 위해서는 대기해야 합니다.
3. 비선점 (Non-preemption) : 점유된 자원은 강제로 해제될 수 없고, 프로세스가 자원의 사용을 자발적을 해제하기 전까지 그 자원은 얻을 수 없습니다.
4. 순환 대기 (Circular Wait) : 자원과 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 합니다.

> InnoDB 스토리지 엔진 데드락 해결방법
> <br>- 데드락 감지 스레드를 사용하는 경우, 데드락 감지 스레드로 주기적으로 잠금 대기 그래프를 검사해 데드락에 빠진 트랜잭션들을 찾어서 그 중 하나를 강제 종료합니다.
> <br>- 동시 처리 스레드가 매우 많아지거나, 각 트랜잭션이 가진 잠금의 개수가 많아질 것이라 예상되는 경우 락을 기다리는 timeout을 설정하면, 데드락 상황에서 벗어날 수 있습니다. 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환합니다.

## 비관적 락과 낙관적 락의 차이에 대해 설명해주세요.
1. 비관적 락
    * 비관적 락은 충돌이 자주 발생할 것으로 가정하고, 데이터를 읽거나 수정하기 전에 해당 데이터에 락을 걸어 다른 트랜잭션이 접근하지 못하도록 합니다.
    * 락을 걸어 다른 트랜잭션의 접근을 차단합니다.
    * 일관성을 유지하는데는 효과적이지만, 락으로 인한 대기 시간이 있고, 데드락의 발생할 수 있습니다.
2. 낙관적 락
    * 낙관적 락은 충돌이 자주 발생하지 않을 것으로 가정하며, 데이터에 락을 걸지 않고 데이터를 읽거나 수정합니다.
    * 데이터를 업데이트 할 때, 데이터가 마지막으로 읽힌 이후 변경되지 않았는지 확인합니다. 이를 위해 버전(version)을 사용합니다.
    * 낙관적 락은 락으로 인한 대기시간이 없어 성능상 이점이 있지만, 충돌감지와 해결을 애플리케이션 레벨에서 관리해야 합니다.

# 공격
## SQL Injection에 대해 설명해주세요.
SQL Injection은 임의의 SQL문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위입니다.

SQL Injection의 종류는 다음과 같습니다.
* Error based SQL Injection : 에러를 발생시켜서 데이터베이스 및 운영 체제의 정보를 획득하는 공격 기법
* Blind SQL Injection : SQL 쿼리의 참/거짓 동작만으로 DB구조를 파악하는 공격 기법

![image](https://github.com/kmularise/TIL/assets/106499310/4a24eb2e-7fa6-444d-a7d1-4d490e4df2dc)


https://noirstar.tistory.com/264


## SQL Injection은 어떻게 막을 수 있을까요?
* Prepared Statement 사용
<br>Prepared Statement 구문을 사용하게 되면, 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기합니다. 이 때 공격 쿼리가 들어간다 해도 사용자의 입력 값을 단순 문자열로 인식하기 때문에 전체 쿼리문이 공격자의 의도대로 작동하지 않습니다.

* 입력 값에 대한 검증
<br>서버 단에서 화이트리스트 기반으로 입력값을 검증해야 합니다. 블랙리스트 기반으로 검증하게 되면 수많은 차단리스트를 등록해야 하고, 하나라도 빠지면 공격에 성공하게 되기 때문입니다.

* 에러 메시지 노출 금지
<br>에러 발생 시 따로 처리를 해줘서, 에러 메시지에 데이터베이스의 정보를 노출시키지 말아야 합니다.




 